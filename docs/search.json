[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CFD Python in Clojure",
    "section": "",
    "text": "1 CFD Python in Clojure\nWe attempt to convert Python written 12 steps of Navier-Stokes learning modules into Clojure. By doing so, the objectives are: 1. going through the steps to learn Computational Fluid Dynamics(CFD) in general 2. convert Python written functions into Clojure, so we could further evolve it to make it use-able in related science research in the future",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CFD Python in Clojure</span>"
    ]
  },
  {
    "objectID": "index.html#navier-stokes-equations",
    "href": "index.html#navier-stokes-equations",
    "title": "CFD Python in Clojure",
    "section": "1.1 Navier-Stokes equations",
    "text": "1.1 Navier-Stokes equations\nNavier-Stokes equations basically describes the movement of viscous fluids using partial differential equations(PDE).\nIn general, the equations explains who fluids reacts around given environment, with states of its density, pressure and temperature.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CFD Python in Clojure</span>"
    ]
  },
  {
    "objectID": "index.html#steps",
    "href": "index.html#steps",
    "title": "CFD Python in Clojure",
    "section": "1.2 Steps",
    "text": "1.2 Steps\n\nStep 1 - 1-D Linear Convection\nStep 2 - Nonlinear Convection\nConvergence and the CFL Condition\nStep 3 - 1-D Diffusion Equation\nStep 4 - 1-D Burgers’ Equation\nStep 5 - 2-D Linear Convection Equation\nStep 6 - 2-D Nonlinear Convection Equation\nStep 7 - 2-D Diffusion Equation\nStep 8 - 2-D Burgers’ Equation\nStep 9 - Laplace Equation\nStep 10 - Poisson Equation\n\n\nsource: notebooks/index.clj",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CFD Python in Clojure</span>"
    ]
  },
  {
    "objectID": "steps.step_01.html",
    "href": "steps.step_01.html",
    "title": "2  1-D Linear Convection",
    "section": "",
    "text": "2.1 What is Convection\nTo briefly describe, convection is like movement affected by the fluid flow itself.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>1-D Linear Convection</span>"
    ]
  },
  {
    "objectID": "steps.step_01.html#the-equation",
    "href": "steps.step_01.html#the-equation",
    "title": "2  1-D Linear Convection",
    "section": "2.2 The Equation",
    "text": "2.2 The Equation\n\\[\\frac{\\partial u }{\\partial t} + c \\frac{\\partial u}{\\partial x} = 0\\]\n\n\\(c\\): speed of initial wave\nInitial condition(at the time \\(t = 0\\), the velocity of the flow, and here it’s understood as a wave) denotes as \\(u_0\\):\n\n\\[u(x, 0) = u_0(x)\\]\nThen the exact solution of the linear convection equation:\n\\[u(x, t) = u_0(x - ct)\\]\nWe discretize this equation in both space and time, using the Forward difference scheme for the time derivative and the Backward difference scheme for the space derivative from the definition of a derivative,\nConsider discretizing the spatial coordinate \\(x\\) into points that we index from \\(i = 0\\) to \\(N\\), and stepping in discrete time intervals of size \\(\\Delta t\\)\n\\[\\frac{\\partial u}{\\partial x} \\approx \\frac{u(x + \\Delta x) - u(x)}{\\Delta x}\\]\ndiscrete equation follows:\n\\[\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + c \\frac{u_i^n - u_{i-1}^n}{\\Delta x} = 0\\]\n\n\\(n\\) & \\(n + 1\\): two consecutive steps in time\n\\(i - 1\\) & \\(i\\): two neighboring points of the discretized x coordinate We can solve for our unknown to get an equation that allows us to advance in time, as follows:\n\n\\[u_i^{n+1} = n_i^n - c \\frac{\\Delta t}{\\Delta x}(u_i^n - u_{i-1}^n)\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>1-D Linear Convection</span>"
    ]
  },
  {
    "objectID": "steps.step_01.html#implementation",
    "href": "steps.step_01.html#implementation",
    "title": "2  1-D Linear Convection",
    "section": "2.3 Implementation",
    "text": "2.3 Implementation\nnx: steps (= 41) dx = 2 / (nx - 1) (x-start = 0, x-end = 2) nt: the number of timesteps we want to calculate (= 25) dt: the amount of time each timestep covers (delta t) (= .25) c: wave speed (= 1)\ninitial conditions: 1. initial velocity \\(u_0\\) is given as \\(u = 2\\) in the interval \\(0.5 \\le x \\le 1\\) and \\(u = 1\\) everywhere else in \\((0, 2)\\)\narray-u outputs:\n\n[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0,\n 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\n 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n\n\ntime to implement discretization of the convention equation using a finite-difference scheme\n\n(def params {:x-start 0\n             :x-end   2\n             :nx      41\n             :nt      20\n             :c       1.0\n             :dt      0.025})\n\n\n(def array-x (one-d/create-array-x params))\n\n\n(def array-u (one-d/create-array-u {:array-x array-x}))\n\n\n(let [nx      41\n      array-x (one-d/create-array-x {:nx nx})\n      array-u (one-d/create-array-u {:array-x array-x})\n      u       (one-d/simulate array-u params)]\n  (kind/vega-lite\n    {:mark     \"line\"\n     :width    500 :height 300\n     :encoding {:x {:field \"x\" :type \"quantitative\"}\n                :y {:field \"y\" :type \"quantitative\"}}\n     :data     {:values (into [] (map #(hash-map :x % :y %2) array-x u))}}))\n\n\n\nsource: notebooks/steps/step_01.clj",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>1-D Linear Convection</span>"
    ]
  },
  {
    "objectID": "steps.step_02.html",
    "href": "steps.step_02.html",
    "title": "3  Nonlinear Convection",
    "section": "",
    "text": "3.1 Implementations\nGoing to implement nonlinear convection in 1D:\n\\[\\frac{\\partial u }{\\partial t} + u \\frac{\\partial u}{\\partial x} = 0\\]\ndifference: instead of a constant \\(c\\), we’re multiplying the solution \\(u\\) onto the second term\nThen the discretized equation is:\n\\[\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + u_i^n \\frac{u_i^n - u_{i-1}^n}{\\Delta x} = 0\\]\nThen, solving for \\(u_i^{n+1}\\):\n\\[u_i^{n+1} = u_i^n - u_i^n \\frac{\\Delta t}{\\Delta x}(u_i^n - u_{i-1}^n)\\]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nonlinear Convection</span>"
    ]
  },
  {
    "objectID": "steps.step_02.html#implementations",
    "href": "steps.step_02.html#implementations",
    "title": "3  Nonlinear Convection",
    "section": "",
    "text": "(def init-params {:x-start 0\n                  :x-end   2\n                  :nx      41\n                  :nt      20\n                  :dt      0.025\n                  :co-eff  :nonlinear})\n\n\n\nsource: notebooks/steps/step_02.clj",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nonlinear Convection</span>"
    ]
  },
  {
    "objectID": "steps.cfl_condition.html",
    "href": "steps.cfl_condition.html",
    "title": "4  Convergence and the CFL Condition",
    "section": "",
    "text": "4.1 Reasons for the breakage\ninitial and boundary conditions:\n41 points of grid and 0.025 sec of timestep.\nExperimenting increasing the size of the grid below to see what happens:\n\\(nx = 41\\)\n\\(nx = 61\\)\n\\(nx = 81\\)\nincreasing grid size means travelling distance within a \\(\\Delta t\\) becomes grater than \\(\\Delta x\\), which correlates to \\(nx\\). In order to enforce the stability, we introduce Courant number \\(\\sigma_{max}\\). This ensures stability with given discretization params.\n\\[\\sigma = \\frac{u \\Delta t}{\\Delta x} \\le \\sigma_{max}\\]\n\\(nx = 41\\)\n\\(nx = 61\\)\n\\(nx = 81\\)\n\\(nx = 101\\)\n\\(nx = 121\\)\nThe results show with a grid size \\(nx\\) increases, convection travels shorter distance. With a given \\(nt = 20\\) in the init param, the time windows becomes shorter as a result of increasing \\(nx\\).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Convergence and the CFL Condition</span>"
    ]
  },
  {
    "objectID": "steps.cfl_condition.html#reasons-for-the-breakage",
    "href": "steps.cfl_condition.html#reasons-for-the-breakage",
    "title": "4  Convergence and the CFL Condition",
    "section": "",
    "text": "(def init-params' {:x-start 0\n                   :x-end   2\n                   :nx      41\n                   :nt      20\n                   :c       1.0\n                   :sigma   0.5})\n\n\n\n\n\n\n\n\n\n\n\n\n\nsource: notebooks/steps/cfl_condition.clj",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Convergence and the CFL Condition</span>"
    ]
  },
  {
    "objectID": "steps.step_03.html",
    "href": "steps.step_03.html",
    "title": "5  1-D Diffusion Equation",
    "section": "",
    "text": "5.1 Discretizing \\(\\frac{\\partial^2 u}{\\partial x^2}\\)\nThe diffusion equation in 1D is:\n\\[\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\\]\nThe equation has second-order derivative, which we first learn how to implement in the code. \\(\\nu\\) is the value of viscosity.\nDescretizing the second-order derivative w/ the Central Difference Scheme: a combination of Forward Difference and Backward Difference of the first derivative.\n\\[u_{i+1} = u_i + \\Delta x \\frac{\\partial u}{\\partial x}\\bigg|_i + \\frac{\\Delta x^2}{2} \\frac{\\partial ^2 u}{\\partial x^2}\\bigg|_i + \\frac{\\Delta x^3}{3!} \\frac{\\partial ^3 u}{\\partial x^3}\\bigg|_i + O(\\Delta x^4)\\]\n\\[u_{i-1} = u_i - \\Delta x \\frac{\\partial u}{\\partial x}\\bigg|_i + \\frac{\\Delta x^2}{2} \\frac{\\partial ^2 u}{\\partial x^2}\\bigg|_i - \\frac{\\Delta x^3}{3!} \\frac{\\partial ^3 u}{\\partial x^3}\\bigg|_i + O(\\Delta x^4)\\]\nNeglecting \\(O(\\Delta x^4)\\) or higher(very small, so neglect-able..)\n\\[u_{i+1} + u_{i_1} = 2u_i + \\Delta x^2 \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_i\\]\nthen put it together w/ the diffusion equation:\n\\[\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\nu\\frac{u_{i+1}^n + u_{i-1}^n - 2u_i^n}{\\Delta x^2}\\]\nthen programmatic equation to solve \\(u\\) is:\n\\[u_i^{n+1} = \\nu\\frac{\\Delta t}{\\Delta x^2}(n_{i+1}^n + u_{i-1}^n - 2u_i^n) + u_i^n\\]",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>1-D Diffusion Equation</span>"
    ]
  },
  {
    "objectID": "steps.step_03.html#discretizing-fracpartial2-upartial-x2",
    "href": "steps.step_03.html#discretizing-fracpartial2-upartial-x2",
    "title": "5  1-D Diffusion Equation",
    "section": "",
    "text": "(def init-params\n  {:mode  :diffusion\n   :nx    42\n   :nt    20\n   :nu    0.3\n   :sigma 0.2})\n\n\n\nsource: notebooks/steps/step_03.clj",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>1-D Diffusion Equation</span>"
    ]
  },
  {
    "objectID": "steps.step_04.html",
    "href": "steps.step_04.html",
    "title": "6  1-D Burgers’ Equation",
    "section": "",
    "text": "6.1 Initials & Boundary Conditions\nA fundamental PDE & convection-diffusion equation.\n\\[\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = \\nu\\frac{\\partial^2 u}{\\partial x^2}\\]\nPreviously, convection eq’n:\n\\[\\frac{\\partial u}{\\partial t} + u\\frac{\\partial u}{\\partial x} = 0\\]\nand diffusion eq’n:\n\\[\\frac{\\partial u}{\\partial t} = \\nu\\frac{\\partial^2 u}{\\partial x^2}\\]\ncombining discretized equations from previous steps\n\\[\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + u_i^n\\frac{u_i^n - u_{i-1}^n}{\\Delta x} = \\nu\\frac{u_{i+1}^n + u_{i-1}^n - 2u_i^n}{\\Delta x^2}\\]\nrearranging the above results:\n\\[u_i^{n+1} = u_i^n - u_i^n \\frac{\\Delta t}{\\Delta x}(u_i^n - u_{i-1}^n) + \\nu\\frac{\\Delta t}{\\Delta x^2}(u_{i+1}^n + u_{i-1}^n - 2u_i^n)\\]",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>1-D Burgers' Equation</span>"
    ]
  },
  {
    "objectID": "steps.step_04.html#initials-boundary-conditions",
    "href": "steps.step_04.html#initials-boundary-conditions",
    "title": "6  1-D Burgers’ Equation",
    "section": "",
    "text": "6.1.1 Initial Conditions\n\\[u = -\\frac{2\\nu}{\\phi}\\frac{\\partial \\phi}{\\partial x} + 4\\]\n\\[\\phi = \\exp\\bigg(\\frac{-(x - 4t)^2}{4\\nu(t + 1)}\\bigg) + \\exp\\bigg(\\frac{-(x - 4t - 2\\pi)^2}{4\\nu(t + 1)}\\bigg)\\]\n\n\n6.1.2 Boundary Condition\n\\[u(0) = u(2\\pi)\\]\nThis is called a periodic boundary condition.\nTesting Burgers’ Eqn: note: currently not using adding equation very organically, so we need to refactor.\n\n(one-d/burgers-u {:t 1.0 :x 4.0 :nu 3.0})\n\n\n3.4917066\n\nWorking on generating lambdify-ed function:\n\n(def nx 101)\n\n\n(def nt 100)\n\n\n(def nu 0.07)\n\n\n(def dx (* 2.0 PI (/ 1 (- nx 1))))\n\n\n(def dt (* dx nu))\n\n\n(def x-start 0)\n\n\n(def x-end (* 2.0 PI))\n\n\n(def init-params\n  {:nx      nx\n   :dx      dx\n   :nt      nt\n   :x-start x-start\n   :x-end   x-end\n   :nu      nu\n   :dt      dt\n   :mode    :burger})\n\nCalculate u and plot:\n\n[3.982484, 4.0450406, 4.1075974, 4.170154, 4.232711, 4.2952676,\n 4.3578243, 4.420381, 4.482938, 4.5454946, 4.6080513, 4.670608,\n 4.733165, 4.7957215, 4.8582783, 4.920835, 4.983392, 5.045948,\n 5.108505, 5.1710615, 5.2336183, 5.296175, 5.3587317, 5.4212885,\n 5.483845, 5.546402, 5.6089587, 5.6715155, 5.734072, 5.796629,\n 5.8591857, 5.9217424, 5.984299, 6.0468554, 6.109412, 6.171969,\n 6.2345257, 6.2970824, 6.359639, 6.422196, 6.4847527, 6.5473094,\n 6.609866, 6.672423, 6.734979, 6.797534, 6.860055, 6.9220233,\n 6.9748416, 6.880349, 5.152262, 1.6489367, 1.0293779, 1.0453354,\n 1.1050574, 1.1674429, 1.2299894, 1.2925454, 1.3551022, 1.4176589,\n 1.4802157, 1.5427722, 1.6053289, 1.6678857, 1.7304426, 1.7929994,\n 1.8555557, 1.9181124, 1.9806691, 2.0432258, 2.1057825, 2.1683393,\n 2.230896, 2.2934527, 2.3560095, 2.4185662, 2.481123, 2.5436797,\n 2.6062365, 2.6687932, 2.73135, 2.7939067, 2.8564634, 2.9190202,\n 2.9815764, 3.0441332, 3.10669, 3.1692467, 3.2318034, 3.2943602,\n 3.356917, 3.4194736, 3.4820304, 3.5445871, 3.6071439, 3.6697006,\n 3.7322574, 3.794814, 3.8573709, 3.9199276, 3.9824843]\n\n\n^^“saw-tooth function”",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>1-D Burgers' Equation</span>"
    ]
  },
  {
    "objectID": "steps.step_04.html#periodic-boundary-conditions",
    "href": "steps.step_04.html#periodic-boundary-conditions",
    "title": "6  1-D Burgers’ Equation",
    "section": "6.2 Periodic Boundary Conditions",
    "text": "6.2 Periodic Boundary Conditions\nWith periodic boundary conditions, when a point gets to the right-hand side of the frame, it wraps around back to the front of the frame.\nBringing the discretized equation from the above:\n\\[u_i^{n+1} = u_i^n - u_i^n \\frac{\\Delta t}{\\Delta x}(u_i^n - u_{i-1}^n) + \\nu\\frac{\\Delta t}{\\Delta x^2}(u_{i+1}^n + u_{i-1}^n - 2u_i^n)\\]\nDrawing both analytical and computational results in the same plot:\n\n\nsource: notebooks/steps/step_04.clj",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>1-D Burgers' Equation</span>"
    ]
  },
  {
    "objectID": "steps.step_05.html",
    "href": "steps.step_05.html",
    "title": "7  Step 5: 2-D Linear Convection",
    "section": "",
    "text": "Expanding from 1D to 2D. Following exercises extends firstly to 2D. The expansion simply requires to apply the definition: a partial derivative with respect to \\(x\\) is the variation in the \\(x\\) direction at constant \\(y\\).\nIn 2D space, a rectangular(uniform) grid is defined by the points with coordinates:\n\\[x_i = x_0 + i \\Delta x\\]\n\\[y_i = y_0 + i \\Delta y\\]\nThen also define $u_{i,j} = u(x_i, y_j) and apply the finite-difference formulas on either variable \\(x, y\\) acting separately on the \\(i\\) and \\(j\\) indices. All derivatives are based on the 2D Taylor expansion of a mesh point value around \\(u_{ij}\\)\nHence, for a first-order partial derivative in the x-direction, a finite-difference formula is:\n\\[\\frac{\\partial u}{\\partial x}\\biggr\\rvert_{i,j} = \\frac{u_{i+1,j}-u_{i,j}}{\\Delta x}+\\mathcal{O}(\\Delta x)\\]\nand similarly in the \\(y\\) direction. Thus, we can write backward-difference, forward-difference or central difference formulas for Step 5 to 12.\nThe PDE governing 2-D Linear Convection is written as\n\\[\\frac{\\partial u}{\\partial t}+c\\frac{\\partial u}{\\partial x} + c\\frac{\\partial u}{\\partial y} = 0\\]\nThis is the same form in 1-D, then added one more dimension to account for as we step forward in time.\nWe will use: - a forward difference discretization for the timestep - a backward difference discretization for two spatial steps\nWith 1-D implementations, we used \\(i\\) subscripts to denote movement in space (e.g. \\(u_i^n - u_{i-1}^n\\)). Now that we have two dimensions to account for, we need to add a second subscript, \\(j\\), to account for all the information in the regime.\nHere, we’ll again use \\(i\\) as the index for our \\(x\\) values, and we’ll add the \\(j\\) subscript to track our \\(y\\) values.\nWith that in mind, our discretization of the PD should be relatively straightforward.\n\\[\\frac{u_{i,j}^{n+1}-u_{i,j}^n}{\\Delta t} + c\\frac{u_{i, j}^n-u_{i-1,j}^n}{\\Delta x} + c\\frac{u_{i,j}^n-u_{i,j-1}^n}{\\Delta y}=0\\]\nAs before, solve for the only unknown:\n\\[u_{i,j}^{n+1} = u_{i,j}^n-c \\frac{\\Delta t}{\\Delta x}(u_{i,j}^n-u_{i-1,j}^n)-c \\frac{\\Delta t}{\\Delta y}(u_{i,j}^n-u_{i,j-1}^n)\\]\nWe will solve this equation with the following initial conditions:\n\\[u(x,y) = \\begin{cases}\n\\begin{matrix}\n2\\ \\text{for} & 0.5 \\leq x, y \\leq 1 \\cr\n1\\ \\text{for} & \\text{everywhere else}\\end{matrix}\\end{cases}\\]\nand the boundary conditions:\n\\[u = 1\\ \\text{for } \\begin{cases}\n\\begin{matrix}\nx =  0,\\ 2 \\cr\ny =  0,\\ 2 \\end{matrix}\\end{cases}\\]\nWe plot here using plotly, then using :mesh3d as the type of the plot. And here’s a reference doc from kindly notebook. The plotting data formats goes like:\n\n_unnamed [6561 3]:\n\n\n\n:x\n:y\n:z\n\n\n\n\n0.000\n0.0\n1.0\n\n\n0.025\n0.0\n1.0\n\n\n0.050\n0.0\n1.0\n\n\n…\n…\n…\n\n\n1.925\n2.0\n1.0\n\n\n1.950\n2.0\n1.0\n\n\n1.975\n2.0\n1.0\n\n\n2.000\n2.0\n1.0\n\n\n\n\ninitial plotting goes:\n\nnote: for now, we skip 3d plotting notes from PythonCFD(further TODO)\n\n7.0.1 Iterating in 2-D w/ linear convection equation\n\n\nsource: notebooks/steps/step_05.clj",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Step 5: 2-D Linear Convection</span>"
    ]
  },
  {
    "objectID": "steps.step_06.html",
    "href": "steps.step_06.html",
    "title": "8  Step 6: 2-D Convection",
    "section": "",
    "text": "Now we solve 2D Convection, represented by the pair of coupled partial differential equations below:\n\\[\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} + v \\frac{\\partial u}{\\partial y} = 0\\]\n\\[\\frac{\\partial v}{\\partial t} + u \\frac{\\partial v}{\\partial x} + v \\frac{\\partial v}{\\partial y} = 0\\]\nDescretizing these equations using the methods we’ve applied previously yields:\n\\[\\frac{u_{i,j}^{n+1}-u_{i,j}^n}{\\Delta t} + u_{i,j}^n \\frac{u_{i,j}^n-u_{i-1,j}^n}{\\Delta x} + v_{i,j}^n \\frac{u_{i,j}^n-u_{i,j-1}^n}{\\Delta y} = 0\\]\n\\[\\frac{v_{i,j}^{n+1}-v_{i,j}^n}{\\Delta t} + u_{i,j}^n \\frac{v_{i,j}^n-v_{i-1,j}^n}{\\Delta x} + v_{i,j}^n \\frac{v_{i,j}^n-v_{i,j-1}^n}{\\Delta y} = 0\\]\nRearranging both equations, we solve for \\(u_{i,j}^{n+1}\\) and \\(v_{i,j}^{n+1}\\), respectively. Note that these equations are also coupled.\n\\[u_{i,j}^{n+1} = u_{i,j}^n - u_{i,j} \\frac{\\Delta t}{\\Delta x} (u_{i,j}^n-u_{i-1,j}^n) - v_{i,j}^n \\frac{\\Delta t}{\\Delta y} (u_{i,j}^n-u_{i,j-1}^n)\\]\n\\[v_{i,j}^{n+1} = v_{i,j}^n - u_{i,j} \\frac{\\Delta t}{\\Delta x} (v_{i,j}^n-v_{i-1,j}^n) - v_{i,j}^n \\frac{\\Delta t}{\\Delta y} (v_{i,j}^n-v_{i,j-1}^n)\\]\n\n8.0.1 Initial Conditions\nThe initial conditions are the same that we used for 1D convection, applied in both the \\(x\\) and \\(y\\) directions.\n\\[u,\\ v\\ = \\begin{cases}\\begin{matrix}\n2 & \\text{for } x,y \\in (0.5, 1)\\times(0.5,1) \\cr\n1 & \\text{everywhere else}\n\\end{matrix}\\end{cases}\\]\n\n\n8.0.2 Boundary Conditions\nThe boundary conditions hold \\(u\\) and \\(v\\) equal to 1 along the boundaries of the grid.\n\\[u = 1,\\ v = 1 \\text{ for } \\begin{cases} \\begin{matrix}x=0,2\\cr y=0,2 \\end{matrix}\\end{cases}\\]\nnumber of x grid points\n\n(def nx 101)\n\nnumber of y grid points\n\n(def ny 101)\n\nnumber of time steps\n\n(def nt 80)\n\nCFL number\n\n(def sigma 0.2)\n\nDefine initial parameters\n\n(def init-params\n  {:nx    nx\n   :ny    ny\n   :nt    nt\n   :c     1\n   :dx    (/ 2 (- nx 1))\n   :dy    (/ 2 (- ny 1))\n   :sigma sigma\n   :dt    (* sigma (/ 2 (- nx 1)))})\n\nCreate the spatial grid\n\n(def grid-start 0)\n\n\n(def grid-end 2)\n\n\n(def spatial-arr (two-d/create-array-2d\n                   (assoc init-params\n                     :x-start grid-start :x-end grid-end\n                     :y-start grid-start :y-end grid-end)))\n\nCreate the initial u and v arrays\n\n(def array-u (two-d/create-init-u init-params spatial-arr))\n\n\n(def array-v (two-d/create-init-u init-params spatial-arr))\n\n\n_unnamed [10201 3]:\n\n\n\n:x\n:y\n:z\n\n\n\n\n0.00\n0.0\n1.0\n\n\n0.02\n0.0\n1.0\n\n\n0.04\n0.0\n1.0\n\n\n…\n…\n…\n\n\n1.94\n2.0\n1.0\n\n\n1.96\n2.0\n1.0\n\n\n1.98\n2.0\n1.0\n\n\n2.00\n2.0\n1.0\n\n\n\n\ninitial plotting w/ \\(x\\), \\(y\\), \\(u\\) goes:\n\n\n\n8.0.3 Iterating in 2-D w/ nonlinear convection equation\nu\n\n(two-d/sim-&gt;plotly-plot-it! spatial-arr (:array-u simulated-result))\n\n\nv\n\n(two-d/sim-&gt;plotly-plot-it! spatial-arr (:array-v simulated-result))\n\n\n\nsource: notebooks/steps/step_06.clj",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 6: 2-D Convection</span>"
    ]
  },
  {
    "objectID": "steps.step_07.html",
    "href": "steps.step_07.html",
    "title": "9  Step 7: 2-D Diffusion",
    "section": "",
    "text": "And here is the 2D-diffusion equation:\n\\[\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial ^2 u}{\\partial x^2} + \\nu \\frac{\\partial ^2 u}{\\partial y^2}\\]\nYou will recall that we came up with a method for discretized second order derivatives in Step 3, when investigating 1-D diffusion. We are going to use the same scheme here, with our forward difference in time and two second-order derivatives.\n\\[\\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t} = \\nu \\frac{u_{i+1,j}^n - 2 u_{i,j}^n + u_{i-1,j}^n}{\\Delta x^2} + \\nu \\frac{u_{i,j+1}^n-2 u_{i,j}^n + u_{i,j-1}^n}{\\Delta y^2}\\]\nOnce again, we reorganize the discretized equation and solve for \\(u_{ij}^{n+1}\\)\n\\[\\begin{split}\nu_{i,j}^{n+1} = u_{i,j}^n &+ \\frac{\\nu \\Delta t}{\\Delta x^2}(u_{i+1,j}^n - 2 u_{i,j}^n + u_{i-1,j}^n) \\\\\n&+ \\frac{\\nu \\Delta t}{\\Delta y^2}(u_{i,j+1}^n-2 u_{i,j}^n + u_{i,j-1}^n)\n\\end{split}\\]\n\n9.0.1 Initial Conditions\n\n(def nx 31)\n\n\n(def ny 31)\n\n\n(def nt 10)\n\nviscosity\n\n(def nu 0.05)\n\nCFL number\n\n(def sigma 0.2)\n\n\n(def dx (/ 2 (- nx 1)))\n\n\n(def dy (/ 2 (- ny 1)))\n\n\n(def init-params\n  {:nx    nx\n   :ny    ny\n   :nu    nu\n   :nt    nt\n   :sigma sigma\n   :dx    dx\n   :dy    dy\n   :dt    (* sigma dx dy (/ 1 nu))})\n\nCreate spatial grid\n\n(def grid-start 0)\n\n\n(def grid-end 2)\n\n\n(def spatial-arr (two-d/create-array-2d\n                   (assoc init-params\n                     :x-start grid-start :x-end grid-end\n                     :y-start grid-start :y-end grid-end)))\n\nCreate the initial u with the initial condition:\n\\[u(x,y) = \\begin{cases}\n\\begin{matrix}\n2\\ \\text{for} & 0.5 \\leq x, y \\leq 1 \\cr\n1\\ \\text{for} & \\text{everywhere else}\\end{matrix}\\end{cases}\\]\n\n(def array-u (two-d/create-init-u init-params spatial-arr))\n\ninitial plotting goes:\n\n\n\n9.0.2 Iterating in 2-D w/ diffusion equation\nat \\(nt=10\\)\n\nat \\(nt=14\\)\n\nat \\(nt=50\\)\n\n\nsource: notebooks/steps/step_07.clj",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Step 7: 2-D Diffusion</span>"
    ]
  },
  {
    "objectID": "steps.step_08.html",
    "href": "steps.step_08.html",
    "title": "10  Step 8: 2-D Burgers’ Equation",
    "section": "",
    "text": "Remember, Burgers’ equations can generate discontinuous solutions from an initial condition that is smooth, i.e., can develop “shocks”. We want to see this in two dimensions now!\nHere is our coupled set of PDEs:\n\\[\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} + v \\frac{\\partial u}{\\partial y} = \\nu \\; \\left(\\frac{\\partial ^2 u}{\\partial x^2} + \\frac{\\partial ^2 u}{\\partial y^2}\\right)\\]\n\\[\\frac{\\partial v}{\\partial t} + u \\frac{\\partial v}{\\partial x} + v \\frac{\\partial v}{\\partial y} = \\nu \\; \\left(\\frac{\\partial ^2 v}{\\partial x^2} + \\frac{\\partial ^2 v}{\\partial y^2}\\right)\\]\nWe know how to discretize each term: we’ve already done it before!\n\\[\\begin{split}\n& \\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t} + u_{i,j}^n \\frac{u_{i,j}^n-u_{i-1,j}^n}{\\Delta x} + v_{i,j}^n \\frac{u_{i,j}^n - u_{i,j-1}^n}{\\Delta y} = \\\\\n& \\qquad \\nu \\left( \\frac{u_{i+1,j}^n - 2u_{i,j}^n+u_{i-1,j}^n}{\\Delta x^2} + \\frac{u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n}{\\Delta y^2} \\right)\n\\end{split}\\]\n\\[\\begin{split}\n& \\frac{v_{i,j}^{n+1} - v_{i,j}^n}{\\Delta t} + u_{i,j}^n \\frac{v_{i,j}^n-v_{i-1,j}^n}{\\Delta x} + v_{i,j}^n \\frac{v_{i,j}^n - v_{i,j-1}^n}{\\Delta y} = \\\\\n& \\qquad \\nu \\left( \\frac{v_{i+1,j}^n - 2v_{i,j}^n+v_{i-1,j}^n}{\\Delta x^2} + \\frac{v_{i,j+1}^n - 2v_{i,j}^n + v_{i,j-1}^n}{\\Delta y^2} \\right)\n\\end{split}\\]\nAnd now, we will rearrange each of these equations for the only unknown: the two components \\(u\\), \\(v\\) of the solution at the next time step:\n\\[\\begin{split}\nu_{i,j}^{n+1} = & u_{i,j}^n - \\frac{\\Delta t}{\\Delta x} u_{i,j}^n (u_{i,j}^n - u_{i-1,j}^n)  - \\frac{\\Delta t}{\\Delta y} v_{i,j}^n (u_{i,j}^n - u_{i,j-1}^n) \\\\\n&+ \\frac{\\nu \\Delta t}{\\Delta x^2}(u_{i+1,j}^n-2u_{i,j}^n+u_{i-1,j}^n) + \\frac{\\nu \\Delta t}{\\Delta y^2} (u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n)\n\\end{split}\\]\n\\[\\begin{split}\nv_{i,j}^{n+1} = & v_{i,j}^n - \\frac{\\Delta t}{\\Delta x} u_{i,j}^n (v_{i,j}^n - v_{i-1,j}^n) - \\frac{\\Delta t}{\\Delta y} v_{i,j}^n (v_{i,j}^n - v_{i,j-1}^n) \\\\\n&+ \\frac{\\nu \\Delta t}{\\Delta x^2}(v_{i+1,j}^n-2v_{i,j}^n+v_{i-1,j}^n) + \\frac{\\nu \\Delta t}{\\Delta y^2} (v_{i,j+1}^n - 2v_{i,j}^n + v_{i,j-1}^n)\n\\end{split}\\]\n\n10.0.1 Initial Conditions\n\n(def nx 41)\n\n\n(def ny 41)\n\n\n(def nt 120)\n\n\n(def c 1)\n\n\n(def nu 0.01)\n\n\n(def sigma 0.0009)\n\n\n(def dx (/ 2 (- nx 1)))\n\n\n(def dy (/ 2 (- ny 1)))\n\n\n(def init-params\n  {:nx    nx\n   :ny    ny\n   :nt    nt\n   :c     c\n   :nu    nu\n   :sigma sigma\n   :dx    dx\n   :dy    dy\n   :dt    (* sigma dx dy (/ 1 nu))})\n\nCreate spatial grid\n\n(def grid-start 0)\n\n\n(def grid-end 2)\n\n\n(def spatial-arr (two-d/create-array-2d\n                   (assoc init-params\n                     :x-start grid-start :x-end grid-end\n                     :y-start grid-start :y-end grid-end)))\n\nCreate the initial u and v arrays w/ initial conditions: u(.5&lt;=x&lt;=1 && .5&lt;=y&lt;=1) is 2, else 1 v(.5&lt;=x&lt;=1 && .5&lt;=y&lt;=1) is 2, else 1\n\n(def array-u (two-d/create-init-u init-params spatial-arr))\n\n\n(def array-v (two-d/create-init-u init-params spatial-arr))\n\ninitial plotting w/ \\(x\\), \\(y\\), \\(u\\) goes:\n\n(two-d/sim-&gt;plotly-plot-it! spatial-arr array-u)\n\n\n\n(def sim-result (two-d/simulate {:array-u array-u\n                                 :array-v array-v} (assoc init-params :mode :burgers)))\n\n\n\nsource: notebooks/steps/step_08.clj",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Step 8: 2-D Burgers' Equation</span>"
    ]
  },
  {
    "objectID": "steps.step_09.html",
    "href": "steps.step_09.html",
    "title": "11  Step 9: 2-D Laplace Equation",
    "section": "",
    "text": "In the previous step, we solved the 2D Burgers’ equation: an important equation in the study of fluid mechanics because it contains the full convective nonlinearity of the flow equations. With that exercise, we also build the experience to incrementally code a Navier-Stokes solver.\nIn the next two steps, we will solve Laplace and then Poisson equation. We will then put it all together!\nHere is Laplace’s equation in 2D:\n\\[\\frac{\\partial ^2 p}{\\partial x^2} + \\frac{\\partial ^2 p}{\\partial y^2} = 0\\]\nWe know how to discretize a 2nd order derivative. But this about this for a minute - Laplace’s equation has the features typical of diffusion phenomena. For this reason, it has to be discretized with central differences, so that the discretization is consistent with the physics we want to simulate.\nThe discretized equation is:\n\\[\\frac{p_{i+1, j}^n - 2p_{i,j}^n + p_{i-1,j}^n}{\\Delta x^2} + \\frac{p_{i,j+1}^n - 2p_{i,j}^n + p_{i, j-1}^n}{\\Delta y^2} = 0\\]\nNotice that the Laplace Equation does not have a time dependence - there is no \\(p^{n+1}\\). Instead of tracking a wave through time (like in the previous steps), the Laplace equation calculates the equilibrium state of a system under the supplied boundary conditions.\nIf you have taken coursework in Heat Transfer, you will recognize the Laplace Equation as the steady-state heat equation.\nInstead of calculating where the system will be at some time \\(t\\), we will iteratively solve for \\(p_{i,j}^n\\) until it meets a condition that we specify. The system will reach equilibrium only as the number of iterations tends to \\(\\infty\\), but we can approximate the equilibrium state by iterating until the change between one iteration and the next is very small.\nLet’s rearrange the discretized equation, solving for \\(p_{i,j}^n\\):\n\\[p_{i,j}^n = \\frac{\\Delta y^2(p_{i+1,j}^n+p_{i-1,j}^n)+\\Delta x^2(p_{i,j+1}^n + p_{i,j-1}^n)}{2(\\Delta x^2 + \\Delta y^2)}\\]\nUsing second order central-difference schemes in both directions is the most widely applied method for the Laplace operator. It is also known as the five-point difference operator, alluding to its stencil.\nWe are going to solve Laplace’s equation numerically by assuming an initial state of \\(p = 0\\) everywhere. Then we add boundary conditions as follows:\n\\(p = 0\\) at \\(x = 0\\) \\(p = y\\) at \\(x = 2\\) \\(\\frac{\\\\Delta p}{\\\\Delta y} = 0\\) at \\(y = 0, 1\\)\nUnder these conditions, there is an analytical solution for Laplace’s equation:\n\\[p(x,y)=\\frac{x}{4}-4\\sum_{n=1,odd}^{\\infty}\\frac{1}{(n\\pi)^2\\sinh2n\\pi}\\sinh n\\pi x\\cos n\\pi y\\]\nDefine the initial parameters\n\n(def nx 31)\n\n\n(def ny 31)\n\n\n(def spatial-init-param\n  {:nx nx :x-start 0 :x-end 2 :dx (double (/ 2 (dec nx)))\n   :ny ny :y-start 0 :y-end 1 :dy (double (/ 1 (dec ny)))})\n\nHave the discretized 2D spatial array ready:\n\n(def spatial-array (two-d/create-array-2d spatial-init-param))\n\n\n(def array-p (two-d/create-init-u\n               (assoc spatial-init-param\n                 :d-type Double/TYPE\n                 :condition-fn (fn [x-val y-val]\n                                 (if (= x-val ((comp last first) spatial-array))\n                                   (double y-val)\n                                   0.0)))\n               spatial-array))\n\n\n11.0.1 Define the Laplace function\nWe will write the Laplace function to solve for \\(p\\) until the change in the L1 Norm of \\(p\\) is less that a specified value.\n\n(def !test (atom []))\n\n\n(= (mapcat identity (mapcat identity (first @!test))) (mapcat identity (second @!test)))\n\n\ntrue\n\n\n(defn laplace-2d [{:keys [spatial-array array-p nx ny dx dy l1norm-target]\n                   :as   params}]\n  (let [[_array-x array-y] spatial-array\n        !l1-norm  (atom 1.0)]\n    (while (&gt; @!l1-norm l1norm-target)\n      (let [pn (aclone array-p)]\n        (dotimes [y-idx (dec ny)]\n          (when (pos? y-idx)\n            (dotimes [x-idx (dec nx)]\n              (when (pos? x-idx)\n                (let [p-j-i+1 (aget pn y-idx (inc x-idx))\n                      p-j-i-1 (aget pn y-idx (dec x-idx))\n                      p-j+1-i (aget pn (inc y-idx) x-idx)\n                      p-j-1-i (aget pn (dec y-idx) x-idx)\n                      dx-2    (pow dx 2)\n                      dy-2    (pow dy 2)]\n                  (aset array-p y-idx x-idx\n                    (double (/ (+ (* dy-2 (+ p-j-i+1 p-j-i-1))\n                                  (* dx-2 (+ p-j+1-i p-j-1-i)))\n                               (* 2 (+ dx-2 dy-2))))))))))\n\n        ;; boundary conditions\n        ;; p = 0 @ x = 0\n        (dotimes [y-idx ny]\n          (aset array-p y-idx 0 0.0))\n        ;; p = y @ x = 2\n        (dotimes [y-idx ny]\n          (aset array-p y-idx (dec nx) (double (aget array-y y-idx))))\n        ;; dp/dy = 0 @ y = 0\n        (dotimes [x-idx nx]\n          (aset array-p 0 x-idx (aget array-p 1 x-idx)))\n        ;; dp/dy = 0 @ y = 1\n        (dotimes [x-idx nx]\n          (aset array-p (dec ny) x-idx (aget array-p (- ny 2) x-idx)))\n        ;; calculate l1nom\n        (reset! !test [array-p pn (l1-norm params pn)])\n        (reset! !l1-norm (l1-norm params pn))))\n    array-p))\n\nNow let’s try looking at our initial condition plot.\n\n(def plotly-surface-plot-base-opts\n  (let [[array-x array-y] spatial-array]\n    {:layout {:scene {:xaxis {:range [0.0 2.1]}\n                      :yaxis {:range [0.0 1.1]}\n                      :zaxis {:range [0.0 1.1]}}}\n     :data   [{:x       array-x\n               :y       array-y\n               :z       array-p\n               :type    :surface\n               :opacity 0.20\n               :color   \"size\"\n               :marker  {:colorscale :Viridis}}]}))\n\n\nWe will have init params for our simulation:\n\n(def init-params\n  (assoc spatial-init-param\n         :spatial-array spatial-array\n         :array-p array-p\n         :l1norm-target 1e-4))\n\nThen run the simulation:\n\n(let [simulated-data (laplace-2d init-params)]\n  (kind/plotly\n    (update-in plotly-surface-plot-base-opts [:data 0] #(assoc % :z simulated-data))))\n\n\n\nsource: notebooks/steps/step_09.clj",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Step 9: 2-D Laplace Equation</span>"
    ]
  },
  {
    "objectID": "steps.step_10.html",
    "href": "steps.step_10.html",
    "title": "12  Step 10: 2D Poisson Equation",
    "section": "",
    "text": ":kindly/hide-code\n\n\n:kindly/hide-code\n\n\n(ns steps.step-10\n  (:require\n   [cfd.two-d :as two-d]\n   [fastmath.core :as fm :refer [pow]]\n   [scicloj.kindly.v4.api :as kindly]\n   [scicloj.kindly.v4.kind :as kind]\n   [utils.notebook :refer [md tex]]))\n\nFor a moment, recall the Navier-Stokes equations for an incompressible fluid, where \\(\\vec{v}\\) represents the velocity field:\n\\[\\begin{eqnarray*}\n\\nabla \\cdot\\vec{v} &=& 0 \\\\\n\\frac{\\partial \\vec{v}}{\\partial t}+(\\vec{v}\\cdot\\nabla)\\vec{v} &=& -\\frac{1}{\\rho}\\nabla p + \\nu \\nabla^2\\vec{v}\n\\end{eqnarray*}\\]\nThe first equation represents mass conservation at constant density. The second equation is the conservation of momentum. But a problem appears: the continuity equation for incompressible flow does not have a dominant variable, and there is no obvious way to couple the velocity and the pressure. In the case of compressible flow, in contrast, mass continuity would provide an evolution for the density \\(\\rho\\), which is coupled with an equation of state relating \\(\\rho\\) and \\(p\\).\nIn incompressible flow, the continuity equation \\(\\nabla \\cdot\\vec{v}=0\\) provides a kinematic constraint that requires the pressure field to evolve so that the rate of expansion \\(\\nabla \\cdot\\vec{v}\\) should vanish everywhere. A way out of this difficulty is to construct a pressure field that guarantees continuity is satisfied; such a relation can be obtained by taking the divergence of the momentum equation. In that process, a Poisson equation for the pressure shows up.\nPoisson’s equation is obtained from adding a source term to the right-hand-side of Laplace’s equation:\n\\[\\frac{\\partial ^2 p}{\\partial x^2} + \\frac{\\partial ^2 p}{\\partial y^2} = b\\]\nSo, unlike the Laplace equation, there is some finite value inside the field that affects the solution. Poisson’s equation acts to “relax” the initial source in the field.\nIn discretized form, this looks almost the same as Step 9, except for the source term:\n\\[\\frac{p_{i+1,j}^{n}-2p_{i,j}^{n}+p_{i-1,j}^{n}}{\\Delta x^2}+\\frac{p_{i,j+1}^{n}-2 p_{i,j}^{n}+p_{i,j-1}^{n}}{\\Delta y^2}=b_{i,j}^{n}\\]\nAs before, we rearrange this so that we obtain an equation for \\(p\\) at point \\(i, j\\). Thus, we obtain:\n\\[p_{i,j}^{n}=\\frac{(p_{i+1,j}^{n}+p_{i-1,j}^{n})\\Delta y^2+(p_{i,j+1}^{n}+p_{i,j-1}^{n})\\Delta x^2-b_{i,j}^{n}\\Delta x^2\\Delta y^2}{2(\\Delta x^2+\\Delta y^2)}\\]\nWe will solve this equation by assuming an initial state of \\(p = 0\\) everywhere, and applying boundary conditions as follows:\n\\(p = 0\\) at \\(x = 0, 2\\) and \\(y = 0, 1\\)\nand the source term consists of two initial spikes inside the domain, as follows:\n\\(b_{i,j}=100\\) at \\(i=\\frac{1}{4}nx, j=\\frac{1}{4}ny\\)\n\\(b_{i,j}=-100\\) at \\(i=\\frac{3}{4}nx, j=\\frac{3}{4}ny\\)\n\\(b_{i,j}=0\\) everywhere else.\nThe iterations will advance in pseudo-time to relax the initial spikes. The relaxation under Poisson’s equation gets slower and slower as they pregress. Why?\n\n(def nx 50)\n\n\n(def ny 50)\n\n\n(def nt 100)\n\n\n(def nt 100)\n\n\n(def spatial-init-param\n  {:nx nx :x-start 0 :x-end 2 :dx (double (/ 2 (dec nx)))\n   :ny ny :y-start 0 :y-end 1 :dy (double (/ 1 (dec ny)))\n   :nt nt})\n\nHave the discretized 2D spatial array ready:\n\n(def spatial-array (two-d/create-array-2d spatial-init-param))\n\n\n(def array-p (two-d/create-init-u\n               (assoc spatial-init-param\n                      :d-type Double/TYPE\n                      :condition-fn (constantly 0.0))\n               spatial-array))\n\n\n(def array-b (aclone array-p))\n\n\n(aset array-b (int (* ny 0.25)) (int (* nx 0.25)) 100.0)\n\n\n100.0\n\n\n(aset array-b (int (* ny 0.25 3)) (int (* nx 0.25 3)) -100.0)\n\n\n-100.0\n\nWith the initial parameters setup above, we are ready to advance the initial guess in pseudo-time. How is the code below difference from the function used in Step 9 to solve Laplace’s equation?\n\n(defn poisson-2d [{:keys [spatial-array\n                          array-p\n                          array-b\n                          nx ny dx dy]\n                   :as   params}]\n  (dotimes [y-idx (- ny 2)]\n    (dotimes [x-idx (- nx 2)]\n      (let [y-idx   (inc y-idx)\n            x-idx   (inc x-idx)\n            pd      (aclone array-p)\n            p-j-i+1 (aget pd y-idx (inc x-idx))\n            p-j-i-1 (aget pd y-idx (dec x-idx))\n            p-j+1-i (aget pd (inc y-idx) x-idx)\n            p-j-1-i (aget pd (dec y-idx) x-idx)\n            b-j-i   (aget array-b y-idx x-idx)\n            dx-2    (pow dx 2)\n            dy-2    (pow dy 2)]\n        (aset array-p y-idx x-idx\n          (/ (+ (* dy-2 (+ p-j-i+1 p-j-i-1))\n                (* dx-2 (+ p-j+1-i p-j-1-i))\n                (* -1.0 b-j-i dx-2 dy-2))\n             (* 2 (+ dx-2 dy-2)))))))\n  (dotimes [y-idx ny]\n    (aset array-p y-idx 0 0.0)\n    (aset array-p y-idx (dec nx) 0.0))\n  (dotimes [x-idx nx]\n    (aset array-p 0 x-idx 0.0)\n    (aset array-p (dec ny) x-idx 0.0)))\n\n\n(defn simulate [{:keys [array-p] :as params}]\n  (loop [n 0]\n    (if (= n nt)\n      array-p\n      (do\n        (poisson-2d params)\n        (recur (inc n))))))\n\n\n(def init-params\n  (assoc spatial-init-param\n         :array-p array-p\n         :array-b array-b))\n\n\n(def plotly-surface-plot-base-opts\n  (let [[array-x array-y] spatial-array]\n    {:layout {:scene {:xaxis {:range [0.0 2.1]}\n                      :yaxis {:range [0.0 1.1]}\n                      :zaxis {:range [-0.2 0.2]}}}\n     :data   [{:x       array-x\n               :y       array-y\n               :z       array-p\n               :type    :surface\n               :opacity 0.20\n               :color   \"size\"\n               :marker  {:colorscale :Viridis}}]}))\n\nRun simulation and plot the result:\n\n(let [simulated-data (simulate init-params)]\n  (kind/plotly\n    (update-in plotly-surface-plot-base-opts\n      [:data 0] #(assoc % :z simulated-data))))\n\n\n\nsource: notebooks/steps/step_10.clj",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Step 10: 2D Poisson Equation</span>"
    ]
  }
]