[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CFD Python in Clojure",
    "section": "",
    "text": "1 CFD Python in Clojure\nWe attempt to convert Python written 12 steps of Navier-Stokes learning modules into Clojure. By doing so, the objectives are: 1. going through the steps to learn Computational Fluid Dynamics(CFD) in general 2. convert Python written functions into Clojure, so we could further evolve it to make it use-able in related science research in the future",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CFD Python in Clojure</span>"
    ]
  },
  {
    "objectID": "index.html#navier-stokes-equations",
    "href": "index.html#navier-stokes-equations",
    "title": "CFD Python in Clojure",
    "section": "1.1 Navier-Stokes equations",
    "text": "1.1 Navier-Stokes equations\nNavier-Stokes equations basically describes the movement of viscous fluids using partial differential equations(PDE).\nIn general, the equations explains who fluids reacts around given environment, with states of its density, pressure and temperature.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CFD Python in Clojure</span>"
    ]
  },
  {
    "objectID": "index.html#steps",
    "href": "index.html#steps",
    "title": "CFD Python in Clojure",
    "section": "1.2 Steps",
    "text": "1.2 Steps\n\nStep 1 - 1-D Linear Convection\nStep 2 - Nonlinear Convection\nConvergence and the CFL Condition\nStep 3 - 1-D Diffusion Equation\nStep 4 - 1-D Burgers’ Equation\nStep 5 - 2-D Linear Convection Equation\nStep 6 - 2-D Nonlinear Convection Equation\nStep 7 - 2-D Diffusion Equation\nStep 8 - 2-D Burgers’ Equation\nStep 9 - Laplace Equation\nStep 10 - Poisson Equation\nStep 11 - Cavity Flow with Navier-Stokes\nStep 12 - Channel Flow with Navier-Stokes\n\n\nsource: notebooks/index.clj",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CFD Python in Clojure</span>"
    ]
  },
  {
    "objectID": "steps.step_01.html",
    "href": "steps.step_01.html",
    "title": "2  1-D Linear Convection",
    "section": "",
    "text": "2.1 What is Convection\nTo briefly describe, convection is like movement affected by the fluid flow itself.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>1-D Linear Convection</span>"
    ]
  },
  {
    "objectID": "steps.step_01.html#the-equation",
    "href": "steps.step_01.html#the-equation",
    "title": "2  1-D Linear Convection",
    "section": "2.2 The Equation",
    "text": "2.2 The Equation\n\\[\\frac{\\partial u }{\\partial t} + c \\frac{\\partial u}{\\partial x} = 0\\]\n\n\\(c\\): speed of initial wave\nInitial condition(at the time \\(t = 0\\), the velocity of the flow, and here it’s understood as a wave) denotes as \\(u_0\\):\n\n\\[u(x, 0) = u_0(x)\\]\nThen the exact solution of the linear convection equation:\n\\[u(x, t) = u_0(x - ct)\\]\nWe discretize this equation in both space and time, using the Forward difference scheme for the time derivative and the Backward difference scheme for the space derivative from the definition of a derivative,\nConsider discretizing the spatial coordinate \\(x\\) into points that we index from \\(i = 0\\) to \\(N\\), and stepping in discrete time intervals of size \\(\\Delta t\\)\n\\[\\frac{\\partial u}{\\partial x} \\approx \\frac{u(x + \\Delta x) - u(x)}{\\Delta x}\\]\ndiscrete equation follows:\n\\[\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + c \\frac{u_i^n - u_{i-1}^n}{\\Delta x} = 0\\]\n\n\\(n\\) & \\(n + 1\\): two consecutive steps in time\n\\(i - 1\\) & \\(i\\): two neighboring points of the discretized x coordinate We can solve for our unknown to get an equation that allows us to advance in time, as follows:\n\n\\[u_i^{n+1} = n_i^n - c \\frac{\\Delta t}{\\Delta x}(u_i^n - u_{i-1}^n)\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>1-D Linear Convection</span>"
    ]
  },
  {
    "objectID": "steps.step_01.html#implementation",
    "href": "steps.step_01.html#implementation",
    "title": "2  1-D Linear Convection",
    "section": "2.3 Implementation",
    "text": "2.3 Implementation\nnx: steps (= 41) dx = 2 / (nx - 1) (x-start = 0, x-end = 2) nt: the number of timesteps we want to calculate (= 25) dt: the amount of time each timestep covers (delta t) (= .25) c: wave speed (= 1)\ninitial conditions: 1. initial velocity \\(u_0\\) is given as \\(u = 2\\) in the interval \\(0.5 \\le x \\le 1\\) and \\(u = 1\\) everywhere else in \\((0, 2)\\)\narray-u outputs:\n\n[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0,\n 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\n 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n\n\ntime to implement discretization of the convention equation using a finite-difference scheme\n\n(def params {:x-start 0\n             :x-end   2\n             :nx      41\n             :nt      20\n             :c       1.0\n             :dt      0.025})\n\n\n(def array-x (one-d/create-array-x params))\n\n\n(def array-u (one-d/create-array-u {:array-x array-x}))\n\n\n(let [nx      41\n      array-x (one-d/create-array-x {:nx nx})\n      array-u (one-d/create-array-u {:array-x array-x})\n      u       (one-d/simulate array-u params)]\n  (kind/vega-lite\n    {:mark     \"line\"\n     :width    500 :height 300\n     :encoding {:x {:field \"x\" :type \"quantitative\"}\n                :y {:field \"y\" :type \"quantitative\"}}\n     :data     {:values (into [] (map #(hash-map :x % :y %2) array-x u))}}))\n\n\n\nsource: notebooks/steps/step_01.clj",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>1-D Linear Convection</span>"
    ]
  },
  {
    "objectID": "steps.step_02.html",
    "href": "steps.step_02.html",
    "title": "3  Nonlinear Convection",
    "section": "",
    "text": "3.1 Implementations\nGoing to implement nonlinear convection in 1D:\n\\[\\frac{\\partial u }{\\partial t} + u \\frac{\\partial u}{\\partial x} = 0\\]\ndifference: instead of a constant \\(c\\), we’re multiplying the solution \\(u\\) onto the second term\nThen the discretized equation is:\n\\[\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + u_i^n \\frac{u_i^n - u_{i-1}^n}{\\Delta x} = 0\\]\nThen, solving for \\(u_i^{n+1}\\):\n\\[u_i^{n+1} = u_i^n - u_i^n \\frac{\\Delta t}{\\Delta x}(u_i^n - u_{i-1}^n)\\]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nonlinear Convection</span>"
    ]
  },
  {
    "objectID": "steps.step_02.html#implementations",
    "href": "steps.step_02.html#implementations",
    "title": "3  Nonlinear Convection",
    "section": "",
    "text": "(def init-params {:x-start 0\n                  :x-end   2\n                  :nx      41\n                  :nt      20\n                  :dt      0.025\n                  :co-eff  :nonlinear})\n\n\n\nsource: notebooks/steps/step_02.clj",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nonlinear Convection</span>"
    ]
  },
  {
    "objectID": "steps.cfl_condition.html",
    "href": "steps.cfl_condition.html",
    "title": "4  Convergence and the CFL Condition",
    "section": "",
    "text": "4.1 Reasons for the breakage\ninitial and boundary conditions:\n41 points of grid and 0.025 sec of timestep.\nExperimenting increasing the size of the grid below to see what happens:\n\\(nx = 41\\)\n\\(nx = 61\\)\n\\(nx = 81\\)\nincreasing grid size means travelling distance within a \\(\\Delta t\\) becomes grater than \\(\\Delta x\\), which correlates to \\(nx\\). In order to enforce the stability, we introduce Courant number \\(\\sigma_{max}\\). This ensures stability with given discretization params.\n\\[\\sigma = \\frac{u \\Delta t}{\\Delta x} \\le \\sigma_{max}\\]\n\\(nx = 41\\)\n\\(nx = 61\\)\n\\(nx = 81\\)\n\\(nx = 101\\)\n\\(nx = 121\\)\nThe results show with a grid size \\(nx\\) increases, convection travels shorter distance. With a given \\(nt = 20\\) in the init param, the time windows becomes shorter as a result of increasing \\(nx\\).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Convergence and the CFL Condition</span>"
    ]
  },
  {
    "objectID": "steps.cfl_condition.html#reasons-for-the-breakage",
    "href": "steps.cfl_condition.html#reasons-for-the-breakage",
    "title": "4  Convergence and the CFL Condition",
    "section": "",
    "text": "(def init-params' {:x-start 0\n                   :x-end   2\n                   :nx      41\n                   :nt      20\n                   :c       1.0\n                   :sigma   0.5})\n\n\n\n\n\n\n\n\n\n\n\n\n\nsource: notebooks/steps/cfl_condition.clj",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Convergence and the CFL Condition</span>"
    ]
  },
  {
    "objectID": "steps.step_03.html",
    "href": "steps.step_03.html",
    "title": "5  1-D Diffusion Equation",
    "section": "",
    "text": "5.1 Discretizing \\(\\frac{\\partial^2 u}{\\partial x^2}\\)\nThe diffusion equation in 1D is:\n\\[\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\\]\nThe equation has second-order derivative, which we first learn how to implement in the code. \\(\\nu\\) is the value of viscosity.\nDescretizing the second-order derivative w/ the Central Difference Scheme: a combination of Forward Difference and Backward Difference of the first derivative.\n\\[u_{i+1} = u_i + \\Delta x \\frac{\\partial u}{\\partial x}\\bigg|_i + \\frac{\\Delta x^2}{2} \\frac{\\partial ^2 u}{\\partial x^2}\\bigg|_i + \\frac{\\Delta x^3}{3!} \\frac{\\partial ^3 u}{\\partial x^3}\\bigg|_i + O(\\Delta x^4)\\]\n\\[u_{i-1} = u_i - \\Delta x \\frac{\\partial u}{\\partial x}\\bigg|_i + \\frac{\\Delta x^2}{2} \\frac{\\partial ^2 u}{\\partial x^2}\\bigg|_i - \\frac{\\Delta x^3}{3!} \\frac{\\partial ^3 u}{\\partial x^3}\\bigg|_i + O(\\Delta x^4)\\]\nNeglecting \\(O(\\Delta x^4)\\) or higher(very small, so neglect-able..)\n\\[u_{i+1} + u_{i_1} = 2u_i + \\Delta x^2 \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_i\\]\nthen put it together w/ the diffusion equation:\n\\[\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\nu\\frac{u_{i+1}^n + u_{i-1}^n - 2u_i^n}{\\Delta x^2}\\]\nthen programmatic equation to solve \\(u\\) is:\n\\[u_i^{n+1} = \\nu\\frac{\\Delta t}{\\Delta x^2}(n_{i+1}^n + u_{i-1}^n - 2u_i^n) + u_i^n\\]",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>1-D Diffusion Equation</span>"
    ]
  },
  {
    "objectID": "steps.step_03.html#discretizing-fracpartial2-upartial-x2",
    "href": "steps.step_03.html#discretizing-fracpartial2-upartial-x2",
    "title": "5  1-D Diffusion Equation",
    "section": "",
    "text": "(def init-params\n  {:mode  :diffusion\n   :nx    42\n   :nt    20\n   :nu    0.3\n   :sigma 0.2})\n\n\n\nsource: notebooks/steps/step_03.clj",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>1-D Diffusion Equation</span>"
    ]
  },
  {
    "objectID": "steps.step_04.html",
    "href": "steps.step_04.html",
    "title": "6  1-D Burgers’ Equation",
    "section": "",
    "text": "6.1 Initials & Boundary Conditions\nA fundamental PDE & convection-diffusion equation.\n\\[\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = \\nu\\frac{\\partial^2 u}{\\partial x^2}\\]\nPreviously, convection eq’n:\n\\[\\frac{\\partial u}{\\partial t} + u\\frac{\\partial u}{\\partial x} = 0\\]\nand diffusion eq’n:\n\\[\\frac{\\partial u}{\\partial t} = \\nu\\frac{\\partial^2 u}{\\partial x^2}\\]\ncombining discretized equations from previous steps\n\\[\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + u_i^n\\frac{u_i^n - u_{i-1}^n}{\\Delta x} = \\nu\\frac{u_{i+1}^n + u_{i-1}^n - 2u_i^n}{\\Delta x^2}\\]\nrearranging the above results:\n\\[u_i^{n+1} = u_i^n - u_i^n \\frac{\\Delta t}{\\Delta x}(u_i^n - u_{i-1}^n) + \\nu\\frac{\\Delta t}{\\Delta x^2}(u_{i+1}^n + u_{i-1}^n - 2u_i^n)\\]",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>1-D Burgers' Equation</span>"
    ]
  },
  {
    "objectID": "steps.step_04.html#initials-boundary-conditions",
    "href": "steps.step_04.html#initials-boundary-conditions",
    "title": "6  1-D Burgers’ Equation",
    "section": "",
    "text": "6.1.1 Initial Conditions\n\\[u = -\\frac{2\\nu}{\\phi}\\frac{\\partial \\phi}{\\partial x} + 4\\]\n\\[\\phi = \\exp\\bigg(\\frac{-(x - 4t)^2}{4\\nu(t + 1)}\\bigg) + \\exp\\bigg(\\frac{-(x - 4t - 2\\pi)^2}{4\\nu(t + 1)}\\bigg)\\]\n\n\n6.1.2 Boundary Condition\n\\[u(0) = u(2\\pi)\\]\nThis is called a periodic boundary condition.\nTesting Burgers’ Eqn: note: currently not using adding equation very organically, so we need to refactor.\n\n(one-d/burgers-u {:t 1.0 :x 4.0 :nu 3.0})\n\n\n3.4917066\n\nWorking on generating lambdify-ed function:\n\n(def nx 101)\n\n\n(def nt 100)\n\n\n(def nu 0.07)\n\n\n(def dx (* 2.0 PI (/ 1 (- nx 1))))\n\n\n(def dt (* dx nu))\n\n\n(def x-start 0)\n\n\n(def x-end (* 2.0 PI))\n\n\n(def init-params\n  {:nx      nx\n   :dx      dx\n   :nt      nt\n   :x-start x-start\n   :x-end   x-end\n   :nu      nu\n   :dt      dt\n   :mode    :burger})\n\nCalculate u and plot:\n\n[3.982484, 4.0450406, 4.1075974, 4.170154, 4.232711, 4.2952676,\n 4.3578243, 4.420381, 4.482938, 4.5454946, 4.6080513, 4.670608,\n 4.733165, 4.7957215, 4.8582783, 4.920835, 4.983392, 5.045948,\n 5.108505, 5.1710615, 5.2336183, 5.296175, 5.3587317, 5.4212885,\n 5.483845, 5.546402, 5.6089587, 5.6715155, 5.734072, 5.796629,\n 5.8591857, 5.9217424, 5.984299, 6.0468554, 6.109412, 6.171969,\n 6.2345257, 6.2970824, 6.359639, 6.422196, 6.4847527, 6.5473094,\n 6.609866, 6.672423, 6.734979, 6.797534, 6.860055, 6.9220233,\n 6.9748416, 6.880349, 5.152262, 1.6489367, 1.0293779, 1.0453354,\n 1.1050574, 1.1674429, 1.2299894, 1.2925454, 1.3551022, 1.4176589,\n 1.4802157, 1.5427722, 1.6053289, 1.6678857, 1.7304426, 1.7929994,\n 1.8555557, 1.9181124, 1.9806691, 2.0432258, 2.1057825, 2.1683393,\n 2.230896, 2.2934527, 2.3560095, 2.4185662, 2.481123, 2.5436797,\n 2.6062365, 2.6687932, 2.73135, 2.7939067, 2.8564634, 2.9190202,\n 2.9815764, 3.0441332, 3.10669, 3.1692467, 3.2318034, 3.2943602,\n 3.356917, 3.4194736, 3.4820304, 3.5445871, 3.6071439, 3.6697006,\n 3.7322574, 3.794814, 3.8573709, 3.9199276, 3.9824843]\n\n\n^^“saw-tooth function”",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>1-D Burgers' Equation</span>"
    ]
  },
  {
    "objectID": "steps.step_04.html#periodic-boundary-conditions",
    "href": "steps.step_04.html#periodic-boundary-conditions",
    "title": "6  1-D Burgers’ Equation",
    "section": "6.2 Periodic Boundary Conditions",
    "text": "6.2 Periodic Boundary Conditions\nWith periodic boundary conditions, when a point gets to the right-hand side of the frame, it wraps around back to the front of the frame.\nBringing the discretized equation from the above:\n\\[u_i^{n+1} = u_i^n - u_i^n \\frac{\\Delta t}{\\Delta x}(u_i^n - u_{i-1}^n) + \\nu\\frac{\\Delta t}{\\Delta x^2}(u_{i+1}^n + u_{i-1}^n - 2u_i^n)\\]\nDrawing both analytical and computational results in the same plot:\n\n\nsource: notebooks/steps/step_04.clj",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>1-D Burgers' Equation</span>"
    ]
  },
  {
    "objectID": "steps.step_05.html",
    "href": "steps.step_05.html",
    "title": "7  Step 5: 2-D Linear Convection",
    "section": "",
    "text": "Expanding from 1D to 2D. Following exercises extends firstly to 2D. The expansion simply requires to apply the definition: a partial derivative with respect to \\(x\\) is the variation in the \\(x\\) direction at constant \\(y\\).\nIn 2D space, a rectangular(uniform) grid is defined by the points with coordinates:\n\\[x_i = x_0 + i \\Delta x\\]\n\\[y_i = y_0 + i \\Delta y\\]\nThen also define $u_{i,j} = u(x_i, y_j) and apply the finite-difference formulas on either variable \\(x, y\\) acting separately on the \\(i\\) and \\(j\\) indices. All derivatives are based on the 2D Taylor expansion of a mesh point value around \\(u_{ij}\\)\nHence, for a first-order partial derivative in the x-direction, a finite-difference formula is:\n\\[\\frac{\\partial u}{\\partial x}\\biggr\\rvert_{i,j} = \\frac{u_{i+1,j}-u_{i,j}}{\\Delta x}+\\mathcal{O}(\\Delta x)\\]\nand similarly in the \\(y\\) direction. Thus, we can write backward-difference, forward-difference or central difference formulas for Step 5 to 12.\nThe PDE governing 2-D Linear Convection is written as\n\\[\\frac{\\partial u}{\\partial t}+c\\frac{\\partial u}{\\partial x} + c\\frac{\\partial u}{\\partial y} = 0\\]\nThis is the same form in 1-D, then added one more dimension to account for as we step forward in time.\nWe will use: - a forward difference discretization for the timestep - a backward difference discretization for two spatial steps\nWith 1-D implementations, we used \\(i\\) subscripts to denote movement in space (e.g. \\(u_i^n - u_{i-1}^n\\)). Now that we have two dimensions to account for, we need to add a second subscript, \\(j\\), to account for all the information in the regime.\nHere, we’ll again use \\(i\\) as the index for our \\(x\\) values, and we’ll add the \\(j\\) subscript to track our \\(y\\) values.\nWith that in mind, our discretization of the PD should be relatively straightforward.\n\\[\\frac{u_{i,j}^{n+1}-u_{i,j}^n}{\\Delta t} + c\\frac{u_{i, j}^n-u_{i-1,j}^n}{\\Delta x} + c\\frac{u_{i,j}^n-u_{i,j-1}^n}{\\Delta y}=0\\]\nAs before, solve for the only unknown:\n\\[u_{i,j}^{n+1} = u_{i,j}^n-c \\frac{\\Delta t}{\\Delta x}(u_{i,j}^n-u_{i-1,j}^n)-c \\frac{\\Delta t}{\\Delta y}(u_{i,j}^n-u_{i,j-1}^n)\\]\nWe will solve this equation with the following initial conditions:\n\\[u(x,y) = \\begin{cases}\n\\begin{matrix}\n2\\ \\text{for} & 0.5 \\leq x, y \\leq 1 \\cr\n1\\ \\text{for} & \\text{everywhere else}\\end{matrix}\\end{cases}\\]\nand the boundary conditions:\n\\[u = 1\\ \\text{for } \\begin{cases}\n\\begin{matrix}\nx =  0,\\ 2 \\cr\ny =  0,\\ 2 \\end{matrix}\\end{cases}\\]\nWe plot here using plotly, then using :mesh3d as the type of the plot. And here’s a reference doc from kindly notebook. The plotting data formats goes like:\n\n_unnamed [6561 3]:\n\n\n\n:x\n:y\n:z\n\n\n\n\n0.000\n0.0\n1.0\n\n\n0.025\n0.0\n1.0\n\n\n0.050\n0.0\n1.0\n\n\n…\n…\n…\n\n\n1.925\n2.0\n1.0\n\n\n1.950\n2.0\n1.0\n\n\n1.975\n2.0\n1.0\n\n\n2.000\n2.0\n1.0\n\n\n\n\ninitial plotting goes:\n\nnote: for now, we skip 3d plotting notes from PythonCFD(further TODO)\n\n7.0.1 Iterating in 2-D w/ linear convection equation\n\n\nsource: notebooks/steps/step_05.clj",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Step 5: 2-D Linear Convection</span>"
    ]
  },
  {
    "objectID": "steps.step_06.html",
    "href": "steps.step_06.html",
    "title": "8  Step 6: 2-D Convection",
    "section": "",
    "text": "Now we solve 2D Convection, represented by the pair of coupled partial differential equations below:\n\\[\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} + v \\frac{\\partial u}{\\partial y} = 0\\]\n\\[\\frac{\\partial v}{\\partial t} + u \\frac{\\partial v}{\\partial x} + v \\frac{\\partial v}{\\partial y} = 0\\]\nDescretizing these equations using the methods we’ve applied previously yields:\n\\[\\frac{u_{i,j}^{n+1}-u_{i,j}^n}{\\Delta t} + u_{i,j}^n \\frac{u_{i,j}^n-u_{i-1,j}^n}{\\Delta x} + v_{i,j}^n \\frac{u_{i,j}^n-u_{i,j-1}^n}{\\Delta y} = 0\\]\n\\[\\frac{v_{i,j}^{n+1}-v_{i,j}^n}{\\Delta t} + u_{i,j}^n \\frac{v_{i,j}^n-v_{i-1,j}^n}{\\Delta x} + v_{i,j}^n \\frac{v_{i,j}^n-v_{i,j-1}^n}{\\Delta y} = 0\\]\nRearranging both equations, we solve for \\(u_{i,j}^{n+1}\\) and \\(v_{i,j}^{n+1}\\), respectively. Note that these equations are also coupled.\n\\[u_{i,j}^{n+1} = u_{i,j}^n - u_{i,j} \\frac{\\Delta t}{\\Delta x} (u_{i,j}^n-u_{i-1,j}^n) - v_{i,j}^n \\frac{\\Delta t}{\\Delta y} (u_{i,j}^n-u_{i,j-1}^n)\\]\n\\[v_{i,j}^{n+1} = v_{i,j}^n - u_{i,j} \\frac{\\Delta t}{\\Delta x} (v_{i,j}^n-v_{i-1,j}^n) - v_{i,j}^n \\frac{\\Delta t}{\\Delta y} (v_{i,j}^n-v_{i,j-1}^n)\\]\n\n8.0.1 Initial Conditions\nThe initial conditions are the same that we used for 1D convection, applied in both the \\(x\\) and \\(y\\) directions.\n\\[u,\\ v\\ = \\begin{cases}\\begin{matrix}\n2 & \\text{for } x,y \\in (0.5, 1)\\times(0.5,1) \\cr\n1 & \\text{everywhere else}\n\\end{matrix}\\end{cases}\\]\n\n\n8.0.2 Boundary Conditions\nThe boundary conditions hold \\(u\\) and \\(v\\) equal to 1 along the boundaries of the grid.\n\\[u = 1,\\ v = 1 \\text{ for } \\begin{cases} \\begin{matrix}x=0,2\\cr y=0,2 \\end{matrix}\\end{cases}\\]\nnumber of x grid points\n\n(def nx 101)\n\nnumber of y grid points\n\n(def ny 101)\n\nnumber of time steps\n\n(def nt 80)\n\nCFL number\n\n(def sigma 0.2)\n\nDefine initial parameters\n\n(def init-params\n  {:nx    nx\n   :ny    ny\n   :nt    nt\n   :c     1\n   :dx    (/ 2 (- nx 1))\n   :dy    (/ 2 (- ny 1))\n   :sigma sigma\n   :dt    (* sigma (/ 2 (- nx 1)))})\n\nCreate the spatial grid\n\n(def grid-start 0)\n\n\n(def grid-end 2)\n\n\n(def spatial-arr (two-d/create-array-2d\n                   (assoc init-params\n                     :x-start grid-start :x-end grid-end\n                     :y-start grid-start :y-end grid-end)))\n\nCreate the initial u and v arrays\n\n(def array-u (two-d/create-init-u init-params spatial-arr))\n\n\n(def array-v (two-d/create-init-u init-params spatial-arr))\n\n\n_unnamed [10201 3]:\n\n\n\n:x\n:y\n:z\n\n\n\n\n0.00\n0.0\n1.0\n\n\n0.02\n0.0\n1.0\n\n\n0.04\n0.0\n1.0\n\n\n…\n…\n…\n\n\n1.94\n2.0\n1.0\n\n\n1.96\n2.0\n1.0\n\n\n1.98\n2.0\n1.0\n\n\n2.00\n2.0\n1.0\n\n\n\n\ninitial plotting w/ \\(x\\), \\(y\\), \\(u\\) goes:\n\n\n\n8.0.3 Iterating in 2-D w/ nonlinear convection equation\nu\n\n(two-d/sim-&gt;plotly-plot-it! spatial-arr (:array-u simulated-result))\n\n\nv\n\n(two-d/sim-&gt;plotly-plot-it! spatial-arr (:array-v simulated-result))\n\n\n\nsource: notebooks/steps/step_06.clj",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 6: 2-D Convection</span>"
    ]
  },
  {
    "objectID": "steps.step_07.html",
    "href": "steps.step_07.html",
    "title": "9  Step 7: 2-D Diffusion",
    "section": "",
    "text": "And here is the 2D-diffusion equation:\n\\[\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial ^2 u}{\\partial x^2} + \\nu \\frac{\\partial ^2 u}{\\partial y^2}\\]\nYou will recall that we came up with a method for discretized second order derivatives in Step 3, when investigating 1-D diffusion. We are going to use the same scheme here, with our forward difference in time and two second-order derivatives.\n\\[\\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t} = \\nu \\frac{u_{i+1,j}^n - 2 u_{i,j}^n + u_{i-1,j}^n}{\\Delta x^2} + \\nu \\frac{u_{i,j+1}^n-2 u_{i,j}^n + u_{i,j-1}^n}{\\Delta y^2}\\]\nOnce again, we reorganize the discretized equation and solve for \\(u_{ij}^{n+1}\\)\n\\[\\begin{split}\nu_{i,j}^{n+1} = u_{i,j}^n &+ \\frac{\\nu \\Delta t}{\\Delta x^2}(u_{i+1,j}^n - 2 u_{i,j}^n + u_{i-1,j}^n) \\\\\n&+ \\frac{\\nu \\Delta t}{\\Delta y^2}(u_{i,j+1}^n-2 u_{i,j}^n + u_{i,j-1}^n)\n\\end{split}\\]\n\n9.0.1 Initial Conditions\n\n(def nx 31)\n\n\n(def ny 31)\n\n\n(def nt 10)\n\nviscosity\n\n(def nu 0.05)\n\nCFL number\n\n(def sigma 0.2)\n\n\n(def dx (/ 2 (- nx 1)))\n\n\n(def dy (/ 2 (- ny 1)))\n\n\n(def init-params\n  {:nx    nx\n   :ny    ny\n   :nu    nu\n   :nt    nt\n   :sigma sigma\n   :dx    dx\n   :dy    dy\n   :dt    (* sigma dx dy (/ 1 nu))})\n\nCreate spatial grid\n\n(def grid-start 0)\n\n\n(def grid-end 2)\n\n\n(def spatial-arr (two-d/create-array-2d\n                   (assoc init-params\n                     :x-start grid-start :x-end grid-end\n                     :y-start grid-start :y-end grid-end)))\n\nCreate the initial u with the initial condition:\n\\[u(x,y) = \\begin{cases}\n\\begin{matrix}\n2\\ \\text{for} & 0.5 \\leq x, y \\leq 1 \\cr\n1\\ \\text{for} & \\text{everywhere else}\\end{matrix}\\end{cases}\\]\n\n(def array-u (two-d/create-init-u init-params spatial-arr))\n\ninitial plotting goes:\n\n\n\n9.0.2 Iterating in 2-D w/ diffusion equation\nat \\(nt=10\\)\n\nat \\(nt=14\\)\n\nat \\(nt=50\\)\n\n\nsource: notebooks/steps/step_07.clj",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Step 7: 2-D Diffusion</span>"
    ]
  },
  {
    "objectID": "steps.step_08.html",
    "href": "steps.step_08.html",
    "title": "10  Step 8: 2-D Burgers’ Equation",
    "section": "",
    "text": "Remember, Burgers’ equations can generate discontinuous solutions from an initial condition that is smooth, i.e., can develop “shocks”. We want to see this in two dimensions now!\nHere is our coupled set of PDEs:\n\\[\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} + v \\frac{\\partial u}{\\partial y} = \\nu \\; \\left(\\frac{\\partial ^2 u}{\\partial x^2} + \\frac{\\partial ^2 u}{\\partial y^2}\\right)\\]\n\\[\\frac{\\partial v}{\\partial t} + u \\frac{\\partial v}{\\partial x} + v \\frac{\\partial v}{\\partial y} = \\nu \\; \\left(\\frac{\\partial ^2 v}{\\partial x^2} + \\frac{\\partial ^2 v}{\\partial y^2}\\right)\\]\nWe know how to discretize each term: we’ve already done it before!\n\\[\\begin{split}\n& \\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t} + u_{i,j}^n \\frac{u_{i,j}^n-u_{i-1,j}^n}{\\Delta x} + v_{i,j}^n \\frac{u_{i,j}^n - u_{i,j-1}^n}{\\Delta y} = \\\\\n& \\qquad \\nu \\left( \\frac{u_{i+1,j}^n - 2u_{i,j}^n+u_{i-1,j}^n}{\\Delta x^2} + \\frac{u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n}{\\Delta y^2} \\right)\n\\end{split}\\]\n\\[\\begin{split}\n& \\frac{v_{i,j}^{n+1} - v_{i,j}^n}{\\Delta t} + u_{i,j}^n \\frac{v_{i,j}^n-v_{i-1,j}^n}{\\Delta x} + v_{i,j}^n \\frac{v_{i,j}^n - v_{i,j-1}^n}{\\Delta y} = \\\\\n& \\qquad \\nu \\left( \\frac{v_{i+1,j}^n - 2v_{i,j}^n+v_{i-1,j}^n}{\\Delta x^2} + \\frac{v_{i,j+1}^n - 2v_{i,j}^n + v_{i,j-1}^n}{\\Delta y^2} \\right)\n\\end{split}\\]\nAnd now, we will rearrange each of these equations for the only unknown: the two components \\(u\\), \\(v\\) of the solution at the next time step:\n\\[\\begin{split}\nu_{i,j}^{n+1} = & u_{i,j}^n - \\frac{\\Delta t}{\\Delta x} u_{i,j}^n (u_{i,j}^n - u_{i-1,j}^n)  - \\frac{\\Delta t}{\\Delta y} v_{i,j}^n (u_{i,j}^n - u_{i,j-1}^n) \\\\\n&+ \\frac{\\nu \\Delta t}{\\Delta x^2}(u_{i+1,j}^n-2u_{i,j}^n+u_{i-1,j}^n) + \\frac{\\nu \\Delta t}{\\Delta y^2} (u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n)\n\\end{split}\\]\n\\[\\begin{split}\nv_{i,j}^{n+1} = & v_{i,j}^n - \\frac{\\Delta t}{\\Delta x} u_{i,j}^n (v_{i,j}^n - v_{i-1,j}^n) - \\frac{\\Delta t}{\\Delta y} v_{i,j}^n (v_{i,j}^n - v_{i,j-1}^n) \\\\\n&+ \\frac{\\nu \\Delta t}{\\Delta x^2}(v_{i+1,j}^n-2v_{i,j}^n+v_{i-1,j}^n) + \\frac{\\nu \\Delta t}{\\Delta y^2} (v_{i,j+1}^n - 2v_{i,j}^n + v_{i,j-1}^n)\n\\end{split}\\]\n\n10.0.1 Initial Conditions\n\n(def nx 41)\n\n\n(def ny 41)\n\n\n(def nt 120)\n\n\n(def c 1)\n\n\n(def nu 0.01)\n\n\n(def sigma 0.0009)\n\n\n(def dx (/ 2 (- nx 1)))\n\n\n(def dy (/ 2 (- ny 1)))\n\n\n(def init-params\n  {:nx    nx\n   :ny    ny\n   :nt    nt\n   :c     c\n   :nu    nu\n   :sigma sigma\n   :dx    dx\n   :dy    dy\n   :dt    (* sigma dx dy (/ 1 nu))})\n\nCreate spatial grid\n\n(def grid-start 0)\n\n\n(def grid-end 2)\n\n\n(def spatial-arr (two-d/create-array-2d\n                   (assoc init-params\n                     :x-start grid-start :x-end grid-end\n                     :y-start grid-start :y-end grid-end)))\n\nCreate the initial u and v arrays w/ initial conditions: u(.5&lt;=x&lt;=1 && .5&lt;=y&lt;=1) is 2, else 1 v(.5&lt;=x&lt;=1 && .5&lt;=y&lt;=1) is 2, else 1\n\n(def array-u (two-d/create-init-u init-params spatial-arr))\n\n\n(def array-v (two-d/create-init-u init-params spatial-arr))\n\ninitial plotting w/ \\(x\\), \\(y\\), \\(u\\) goes:\n\n(two-d/sim-&gt;plotly-plot-it! spatial-arr array-u)\n\n\n\n(def sim-result (two-d/simulate {:array-u array-u\n                                 :array-v array-v} (assoc init-params :mode :burgers)))\n\n\n\nsource: notebooks/steps/step_08.clj",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Step 8: 2-D Burgers' Equation</span>"
    ]
  },
  {
    "objectID": "steps.step_09.html",
    "href": "steps.step_09.html",
    "title": "11  Step 9: 2-D Laplace Equation",
    "section": "",
    "text": "In the previous step, we solved the 2D Burgers’ equation: an important equation in the study of fluid mechanics because it contains the full convective nonlinearity of the flow equations. With that exercise, we also build the experience to incrementally code a Navier-Stokes solver.\nIn the next two steps, we will solve Laplace and then Poisson equation. We will then put it all together!\nHere is Laplace’s equation in 2D:\n\\[\\frac{\\partial ^2 p}{\\partial x^2} + \\frac{\\partial ^2 p}{\\partial y^2} = 0\\]\nWe know how to discretize a 2nd order derivative. But this about this for a minute - Laplace’s equation has the features typical of diffusion phenomena. For this reason, it has to be discretized with central differences, so that the discretization is consistent with the physics we want to simulate.\nThe discretized equation is:\n\\[\\frac{p_{i+1, j}^n - 2p_{i,j}^n + p_{i-1,j}^n}{\\Delta x^2} + \\frac{p_{i,j+1}^n - 2p_{i,j}^n + p_{i, j-1}^n}{\\Delta y^2} = 0\\]\nNotice that the Laplace Equation does not have a time dependence - there is no \\(p^{n+1}\\). Instead of tracking a wave through time (like in the previous steps), the Laplace equation calculates the equilibrium state of a system under the supplied boundary conditions.\nIf you have taken coursework in Heat Transfer, you will recognize the Laplace Equation as the steady-state heat equation.\nInstead of calculating where the system will be at some time \\(t\\), we will iteratively solve for \\(p_{i,j}^n\\) until it meets a condition that we specify. The system will reach equilibrium only as the number of iterations tends to \\(\\infty\\), but we can approximate the equilibrium state by iterating until the change between one iteration and the next is very small.\nLet’s rearrange the discretized equation, solving for \\(p_{i,j}^n\\):\n\\[p_{i,j}^n = \\frac{\\Delta y^2(p_{i+1,j}^n+p_{i-1,j}^n)+\\Delta x^2(p_{i,j+1}^n + p_{i,j-1}^n)}{2(\\Delta x^2 + \\Delta y^2)}\\]\nUsing second order central-difference schemes in both directions is the most widely applied method for the Laplace operator. It is also known as the five-point difference operator, alluding to its stencil.\nWe are going to solve Laplace’s equation numerically by assuming an initial state of \\(p = 0\\) everywhere. Then we add boundary conditions as follows:\n\\(p = 0\\) at \\(x = 0\\) \\(p = y\\) at \\(x = 2\\) \\(\\frac{\\\\Delta p}{\\\\Delta y} = 0\\) at \\(y = 0, 1\\)\nUnder these conditions, there is an analytical solution for Laplace’s equation:\n\\[p(x,y)=\\frac{x}{4}-4\\sum_{n=1,odd}^{\\infty}\\frac{1}{(n\\pi)^2\\sinh2n\\pi}\\sinh n\\pi x\\cos n\\pi y\\]\nDefine the initial parameters\n\n(def nx 31)\n\n\n(def ny 31)\n\n\n(def spatial-init-param\n  {:nx nx :x-start 0 :x-end 2 :dx (double (/ 2 (dec nx)))\n   :ny ny :y-start 0 :y-end 1 :dy (double (/ 1 (dec ny)))})\n\nHave the discretized 2D spatial array ready:\n\n(def spatial-array (two-d/create-array-2d spatial-init-param))\n\n\n(def array-p (two-d/create-init-u\n               (assoc spatial-init-param\n                 :d-type Double/TYPE\n                 :condition-fn (fn [x-val y-val]\n                                 (if (= x-val ((comp last first) spatial-array))\n                                   (double y-val)\n                                   0.0)))\n               spatial-array))\n\n\n11.0.1 Define the Laplace function\nWe will write the Laplace function to solve for \\(p\\) until the change in the L1 Norm of \\(p\\) is less that a specified value.\n\n(defn laplace-2d [{:keys [spatial-array array-p nx ny dx dy l1norm-target]\n                   :as   params}]\n  (let [[_array-x array-y] spatial-array\n        !l1-norm (atom 1.0)]\n    (while (&gt; @!l1-norm l1norm-target)\n      (let [pn (two-d/clone-2d-array array-p)]\n        (dotimes [y-idx (dec ny)]\n          (when (pos? y-idx)\n            (dotimes [x-idx (dec nx)]\n              (when (pos? x-idx)\n                (let [p-j-i+1 (aget pn y-idx (inc x-idx))\n                      p-j-i-1 (aget pn y-idx (dec x-idx))\n                      p-j+1-i (aget pn (inc y-idx) x-idx)\n                      p-j-1-i (aget pn (dec y-idx) x-idx)\n                      dx-2    (pow dx 2)\n                      dy-2    (pow dy 2)]\n                  (aset array-p y-idx x-idx\n                    (double (/ (+ (* dy-2 (+ p-j-i+1 p-j-i-1))\n                                  (* dx-2 (+ p-j+1-i p-j-1-i)))\n                               (* 2 (+ dx-2 dy-2))))))))))\n        ;; boundary conditions\n        ;; p = 0 @ x = 0\n        (dotimes [y-idx ny]\n          (aset array-p y-idx 0 0.0))\n        ;; p = y @ x = 2\n        (dotimes [y-idx ny]\n          (aset array-p y-idx (dec nx) (double (aget array-y y-idx))))\n        ;; dp/dy = 0 @ y = 0\n        (dotimes [x-idx nx]\n          (aset array-p 0 x-idx (aget array-p 1 x-idx)))\n        ;; dp/dy = 0 @ y = 1\n        (dotimes [x-idx nx]\n          (aset array-p (dec ny) x-idx (aget array-p (- ny 2) x-idx)))\n        ;; calculate l1nom\n        (reset! !l1-norm (l1-norm params pn))))\n    array-p))\n\nNow let’s try looking at our initial condition plot.\n\n(def plotly-surface-plot-base-opts\n  (let [[array-x array-y] spatial-array]\n    {:layout {:scene {:xaxis {:range [0.0 2.1]}\n                      :yaxis {:range [0.0 1.1]}\n                      :zaxis {:range [0.0 1.1]}}}\n     :data   [{:x       array-x\n               :y       array-y\n               :z       array-p\n               :type    :surface\n               :opacity 0.20\n               :color   \"size\"\n               :marker  {:colorscale :Viridis}}]}))\n\n\nWe will have init params for our simulation:\n\n(def init-params\n  (assoc spatial-init-param\n         :spatial-array spatial-array\n         :array-p array-p\n         :l1norm-target 1e-4))\n\nThen run the simulation:\n\n(let [simulated-data (laplace-2d init-params)]\n  (kind/plotly\n    (update-in plotly-surface-plot-base-opts [:data 0] #(assoc % :z simulated-data))))\n\n\n\nsource: notebooks/steps/step_09.clj",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Step 9: 2-D Laplace Equation</span>"
    ]
  },
  {
    "objectID": "steps.step_10.html",
    "href": "steps.step_10.html",
    "title": "12  Step 10: 2D Poisson Equation",
    "section": "",
    "text": "For a moment, recall the Navier-Stokes equations for an incompressible fluid, where \\(\\vec{v}\\) represents the velocity field:\n\\[\\begin{eqnarray*}\n\\nabla \\cdot\\vec{v} &=& 0 \\\\\n\\frac{\\partial \\vec{v}}{\\partial t}+(\\vec{v}\\cdot\\nabla)\\vec{v} &=& -\\frac{1}{\\rho}\\nabla p + \\nu \\nabla^2\\vec{v}\n\\end{eqnarray*}\\]\nThe first equation represents mass conservation at constant density. The second equation is the conservation of momentum. But a problem appears: the continuity equation for incompressible flow does not have a dominant variable, and there is no obvious way to couple the velocity and the pressure. In the case of compressible flow, in contrast, mass continuity would provide an evolution for the density \\(\\rho\\), which is coupled with an equation of state relating \\(\\rho\\) and \\(p\\).\nIn incompressible flow, the continuity equation \\(\\nabla \\cdot\\vec{v}=0\\) provides a kinematic constraint that requires the pressure field to evolve so that the rate of expansion \\(\\nabla \\cdot\\vec{v}\\) should vanish everywhere. A way out of this difficulty is to construct a pressure field that guarantees continuity is satisfied; such a relation can be obtained by taking the divergence of the momentum equation. In that process, a Poisson equation for the pressure shows up.\nPoisson’s equation is obtained from adding a source term to the right-hand-side of Laplace’s equation:\n\\[\\frac{\\partial ^2 p}{\\partial x^2} + \\frac{\\partial ^2 p}{\\partial y^2} = b\\]\nSo, unlike the Laplace equation, there is some finite value inside the field that affects the solution. Poisson’s equation acts to “relax” the initial source in the field.\nIn discretized form, this looks almost the same as Step 9, except for the source term:\n\\[\\frac{p_{i+1,j}^{n}-2p_{i,j}^{n}+p_{i-1,j}^{n}}{\\Delta x^2}+\\frac{p_{i,j+1}^{n}-2 p_{i,j}^{n}+p_{i,j-1}^{n}}{\\Delta y^2}=b_{i,j}^{n}\\]\nAs before, we rearrange this so that we obtain an equation for \\(p\\) at point \\(i, j\\). Thus, we obtain:\n\\[p_{i,j}^{n}=\\frac{(p_{i+1,j}^{n}+p_{i-1,j}^{n})\\Delta y^2+(p_{i,j+1}^{n}+p_{i,j-1}^{n})\\Delta x^2-b_{i,j}^{n}\\Delta x^2\\Delta y^2}{2(\\Delta x^2+\\Delta y^2)}\\]\nWe will solve this equation by assuming an initial state of \\(p = 0\\) everywhere, and applying boundary conditions as follows:\n\\(p = 0\\) at \\(x = 0, 2\\) and \\(y = 0, 1\\)\nand the source term consists of two initial spikes inside the domain, as follows:\n\\(b_{i,j}=100\\) at \\(i=\\frac{1}{4}nx, j=\\frac{1}{4}ny\\)\n\\(b_{i,j}=-100\\) at \\(i=\\frac{3}{4}nx, j=\\frac{3}{4}ny\\)\n\\(b_{i,j}=0\\) everywhere else.\nThe iterations will advance in pseudo-time to relax the initial spikes. The relaxation under Poisson’s equation gets slower and slower as they pregress. Why?\n\n(def nx 50)\n\n\n(def ny 50)\n\n\n(def nt 100)\n\n\n(def nt 100)\n\n\n(def spatial-init-param\n  {:nx nx :x-start 0 :x-end 2 :dx (double (/ 2 (dec nx)))\n   :ny ny :y-start 0 :y-end 1 :dy (double (/ 1 (dec ny)))\n   :nt nt})\n\nHave the discretized 2D spatial array ready:\n\n(def spatial-array (two-d/create-array-2d spatial-init-param))\n\n\n(def array-p (two-d/create-init-u\n               (assoc spatial-init-param\n                      :d-type Double/TYPE\n                      :condition-fn (constantly 0.0))\n               spatial-array))\n\n\n(def array-b (aclone array-p))\n\n\n(aset array-b (int (* ny 0.25)) (int (* nx 0.25)) 100.0)\n\n\n100.0\n\n\n(aset array-b (int (* ny 0.25 3)) (int (* nx 0.25 3)) -100.0)\n\n\n-100.0\n\nWith the initial parameters setup above, we are ready to advance the initial guess in pseudo-time. How is the code below difference from the function used in Step 9 to solve Laplace’s equation?\n\n(defn poisson-2d [{:keys [spatial-array\n                          array-p\n                          array-b\n                          nx ny dx dy]\n                   :as   params}]\n  (dotimes [y-idx (- ny 2)]\n    (dotimes [x-idx (- nx 2)]\n      (let [y-idx   (inc y-idx)\n            x-idx   (inc x-idx)\n            pd      (two-d/clone-2d-array array-p)\n            p-j-i+1 (aget pd y-idx (inc x-idx))\n            p-j-i-1 (aget pd y-idx (dec x-idx))\n            p-j+1-i (aget pd (inc y-idx) x-idx)\n            p-j-1-i (aget pd (dec y-idx) x-idx)\n            b-j-i   (aget array-b y-idx x-idx)\n            dx-2    (pow dx 2)\n            dy-2    (pow dy 2)]\n        (aset array-p y-idx x-idx\n          (/ (+ (* dy-2 (+ p-j-i+1 p-j-i-1))\n                (* dx-2 (+ p-j+1-i p-j-1-i))\n                (* -1.0 b-j-i dx-2 dy-2))\n             (* 2 (+ dx-2 dy-2)))))))\n  (dotimes [y-idx ny]\n    (aset array-p y-idx 0 0.0)\n    (aset array-p y-idx (dec nx) 0.0))\n  (dotimes [x-idx nx]\n    (aset array-p 0 x-idx 0.0)\n    (aset array-p (dec ny) x-idx 0.0)))\n\n\n(defn simulate [{:keys [array-p] :as params}]\n  (loop [n 0]\n    (if (= n nt)\n      array-p\n      (do\n        (poisson-2d params)\n        (recur (inc n))))))\n\n\n(def init-params\n  (assoc spatial-init-param\n         :array-p array-p\n         :array-b array-b))\n\n\n(def plotly-surface-plot-base-opts\n  (let [[array-x array-y] spatial-array]\n    {:layout {:scene {:xaxis {:range [0.0 2.1]}\n                      :yaxis {:range [0.0 1.1]}\n                      :zaxis {:range [-0.2 0.2]}}}\n     :data   [{:x       array-x\n               :y       array-y\n               :z       array-p\n               :type    :surface\n               :opacity 0.20\n               :color   \"size\"\n               :marker  {:colorscale :Viridis}}]}))\n\nRun simulation and plot the result:\n\n(let [simulated-data (simulate init-params)]\n  (kind/plotly\n    (update-in plotly-surface-plot-base-opts\n      [:data 0] #(assoc % :z simulated-data))))\n\n\n\nsource: notebooks/steps/step_10.clj",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Step 10: 2D Poisson Equation</span>"
    ]
  },
  {
    "objectID": "steps.step_11.html",
    "href": "steps.step_11.html",
    "title": "13  Step 11: Cavity Flow with Navier-Stokes",
    "section": "",
    "text": "The final two steps in this interactive module porting CFD Python into Clojure will both solve both the Navier-Stokes equations in two dimensions, but with different boundary conditions.\nThe momentum equation in vector form for a velocity field \\(\\vec{v}\\) is:\n\\[\\frac{\\partial \\vec{v}}{\\partial t}+(\\vec{v}\\cdot\\nabla)\\vec{v}=-\\frac{1}{\\rho}\\nabla p + \\nu \\nabla^2\\vec{v}\\]\nThis represents three scalar equations, one for each velocity component \\((u, v, w)\\). But we will solve it in two dimensions, so there will be two scalar equations.\nRemember the continuity equation? This is where the Poisson equation for pressure comes in!\nHere is the system of differential equations: two equations for the velocity components \\(u\\), \\(v\\) and one equation for pressure:\n\\[\\frac{\\partial u}{\\partial t}+u\\frac{\\partial u}{\\partial x}+v\\frac{\\partial u}{\\partial y} = -\\frac{1}{\\rho}\\frac{\\partial p}{\\partial x}+\\nu \\left(\\frac{\\partial^2 u}{\\partial x^2}+\\frac{\\partial^2 u}{\\partial y^2} \\right)\\]\n\\[\\frac{\\partial v}{\\partial t}+u\\frac{\\partial v}{\\partial x}+v\\frac{\\partial v}{\\partial y} = -\\frac{1}{\\rho}\\frac{\\partial p}{\\partial y}+\\nu\\left(\\frac{\\partial^2 v}{\\partial x^2}+\\frac{\\partial^2 v}{\\partial y^2}\\right)\\]\n\\[\\frac{\\partial^2 p}{\\partial x^2}+\\frac{\\partial^2 p}{\\partial y^2} = -\\rho\\left(\\frac{\\partial u}{\\partial x}\\frac{\\partial u}{\\partial x}+2\\frac{\\partial u}{\\partial y}\\frac{\\partial v}{\\partial x}+\\frac{\\partial v}{\\partial y}\\frac{\\partial v}{\\partial y} \\right)\\]\nFrom the previous steps, we already know how to discretize all these terms. Only the last equation is a little unfamiliar. But with a little patience, it will not be hard!\n\n13.0.1 Discretized equations\nFirst, let’s discretize the \\(u\\)-momentum equation, as follows:\n\\[\\begin{split}\n& \\frac{u_{i,j}^{n+1}-u_{i,j}^{n}}{\\Delta t}+u_{i,j}^{n}\\frac{u_{i,j}^{n}-u_{i-1,j}^{n}}{\\Delta x}+v_{i,j}^{n}\\frac{u_{i,j}^{n}-u_{i,j-1}^{n}}{\\Delta y} = \\\\\n& \\qquad -\\frac{1}{\\rho}\\frac{p_{i+1,j}^{n}-p_{i-1,j}^{n}}{2\\Delta x}+\\nu\\left(\\frac{u_{i+1,j}^{n}-2u_{i,j}^{n}+u_{i-1,j}^{n}}{\\Delta x^2}+\\frac{u_{i,j+1}^{n}-2u_{i,j}^{n}+u_{i,j-1}^{n}}{\\Delta y^2}\\right)\n\\end{split}\\]\nSimilarly for the \\(v\\)-momentum equation:\n\\[\\begin{split}\n&\\frac{v_{i,j}^{n+1}-v_{i,j}^{n}}{\\Delta t}+u_{i,j}^{n}\\frac{v_{i,j}^{n}-v_{i-1,j}^{n}}{\\Delta x}+v_{i,j}^{n}\\frac{v_{i,j}^{n}-v_{i,j-1}^{n}}{\\Delta y} = \\\\\n& \\qquad -\\frac{1}{\\rho}\\frac{p_{i,j+1}^{n}-p_{i,j-1}^{n}}{2\\Delta y}\n+\\nu\\left(\\frac{v_{i+1,j}^{n}-2v_{i,j}^{n}+v_{i-1,j}^{n}}{\\Delta x^2}+\\frac{v_{i,j+1}^{n}-2v_{i,j}^{n}+v_{i,j-1}^{n}}{\\Delta y^2}\\right)\n\\end{split}\\]\nFinally, the discretized pressure-Poisson equation can be written thus:\n\\[\\begin{split}\n& \\frac{p_{i+1,j}^{n}-2p_{i,j}^{n}+p_{i-1,j}^{n}}{\\Delta x^2}+\\frac{p_{i,j+1}^{n}-2p_{i,j}^{n}+p_{i,j-1}^{n}}{\\Delta y^2} = \\\\\n& \\qquad \\rho \\left[ \\frac{1}{\\Delta t}\\left(\\frac{u_{i+1,j}-u_{i-1,j}}{2\\Delta x}+\\frac{v_{i,j+1}-v_{i,j-1}}{2\\Delta y}\\right) -\\frac{u_{i+1,j}-u_{i-1,j}}{2\\Delta x}\\frac{u_{i+1,j}-u_{i-1,j}}{2\\Delta x} - 2\\frac{u_{i,j+1}-u_{i,j-1}}{2\\Delta y}\\frac{v_{i+1,j}-v_{i-1,j}}{2\\Delta x} - \\frac{v_{i,j+1}-v_{i,j-1}}{2\\Delta y}\\frac{v_{i,j+1}-v_{i,j-1}}{2\\Delta y}\\right]\n\\end{split}\\]\nYou should write these equations down on your own notes, by hand, following each term mentally as you write it.\nAs before, let’s rearrange the equations in the way that the iterations need to proceed in the code. First, the momentum equations for the velocity at the next time step.\nThe momentum equation in the \\(u\\) direction:\n\\[\\begin{split}\nu_{i,j}^{n+1} = u_{i,j}^{n} & - u_{i,j}^{n} \\frac{\\Delta t}{\\Delta x} \\left(u_{i,j}^{n}-u_{i-1,j}^{n}\\right) - v_{i,j}^{n} \\frac{\\Delta t}{\\Delta y} \\left(u_{i,j}^{n}-u_{i,j-1}^{n}\\right) \\\\\n& - \\frac{\\Delta t}{\\rho 2\\Delta x} \\left(p_{i+1,j}^{n}-p_{i-1,j}^{n}\\right) \\\\\n& + \\nu \\left(\\frac{\\Delta t}{\\Delta x^2} \\left(u_{i+1,j}^{n}-2u_{i,j}^{n}+u_{i-1,j}^{n}\\right) + \\frac{\\Delta t}{\\Delta y^2} \\left(u_{i,j+1}^{n}-2u_{i,j}^{n}+u_{i,j-1}^{n}\\right)\\right)\n\\end{split}\\]\nThe momentum equation in the \\(v\\) direction:\n\\[\\begin{split}\nv_{i,j}^{n+1} = v_{i,j}^{n} & - u_{i,j}^{n} \\frac{\\Delta t}{\\Delta x} \\left(v_{i,j}^{n}-v_{i-1,j}^{n}\\right) - v_{i,j}^{n} \\frac{\\Delta t}{\\Delta y} \\left(v_{i,j}^{n}-v_{i,j-1}^{n})\\right) \\\\\n& - \\frac{\\Delta t}{\\rho 2\\Delta y} \\left(p_{i,j+1}^{n}-p_{i,j-1}^{n}\\right) \\\\\n& + \\nu \\left(\\frac{\\Delta t}{\\Delta x^2} \\left(v_{i+1,j}^{n}-2v_{i,j}^{n}+v_{i-1,j}^{n}\\right) + \\frac{\\Delta t}{\\Delta y^2} \\left(v_{i,j+1}^{n}-2v_{i,j}^{n}+v_{i,j-1}^{n}\\right)\\right)\n\\end{split}\\]\nAlmost there! Now, we rearrange the pressure-Poisson equation:\n\\[\\begin{split}\np_{i,j}^{n} = & \\frac{\\left(p_{i+1,j}^{n}+p_{i-1,j}^{n}\\right) \\Delta y^2 + \\left(p_{i,j+1}^{n}+p_{i,j-1}^{n}\\right) \\Delta x^2}{2\\left(\\Delta x^2+\\Delta y^2\\right)} \\\\\n& -\\frac{\\rho\\Delta x^2\\Delta y^2}{2\\left(\\Delta x^2+\\Delta y^2\\right)} \\\\\n& \\times \\left[\\frac{1}{\\Delta t}\\left(\\frac{u_{i+1,j}-u_{i-1,j}}{2\\Delta x}+\\frac{v_{i,j+1}-v_{i,j-1}}{2\\Delta y}\\right)-\\frac{u_{i+1,j}-u_{i-1,j}}{2\\Delta x}\\frac{u_{i+1,j}-u_{i-1,j}}{2\\Delta x} -2\\frac{u_{i,j+1}-u_{i,j-1}}{2\\Delta y}\\frac{v_{i+1,j}-v_{i-1,j}}{2\\Delta x}-\\frac{v_{i,j+1}-v_{i,j-1}}{2\\Delta y}\\frac{v_{i,j+1}-v_{i,j-1}}{2\\Delta y}\\right]\n\\end{split}\\]\nThe initial condition is \\(u, v, p = 0\\) everywhere, and the boundary conditions are:\n\\(u = 1\\) at \\(y = 2\\) (the “lid”)  \\(u, v = 0\\) on the other boundaries  \\(\\frac{\\partial p}{\\partial y} = 0\\) at \\(y = 0\\)  \\(p = 0\\) at \\(y = 2\\)  \\(\\frac{\\partial p}{\\partial x} = 0\\) at \\(x = 0, 2\\)\n\n\n13.0.2 Implementing Cavity Flow\nSpatial setup:\n\n(def nx 41)\n\n\n(def ny 41)\n\n\n(def nt 500)\n\n\n(def nit 50)\n\n\n(def c 1)\n\n\n(def x-start 0)\n\n\n(def x-end 2)\n\n\n(def y-start 0)\n\n\n(def y-end 2)\n\n\n(def dx (double (/ (- x-end x-start) (dec nx))))\n\n\n(def dy (double (/ (- y-end y-start) (dec ny))))\n\n\n(def spatial-init-params\n  {:nx nx :x-start x-start :x-end x-end :dx dx :x-end-idx (dec nx) :x-second-end-idx (- nx 2)\n   :ny ny :y-start y-start :y-end y-end :dy dy :y-end-idx (dec ny) :y-second-end-idx (- ny 2)})\n\n\n(def spatial-array (two-d/create-array-2d spatial-init-params))\n\nThe rest setup:\n\n(def rho 1.0)\n\n\n(def nu 0.1)\n\n\n(def dt 0.001)\n\nDoing some pre-calculation to optimize the performance\n\n(def pre-calculation-params\n  {:two-dx                (* 2.0 dx)\n   :two-dy                (* 2.0 dy)\n   :two-dx-dy             (* 2.0 dx dy)\n   :dx-square             (pow dx 2)\n   :dy-square             (pow dy 2)\n   :four-dx-square        (* 4.0 (pow dx 2))\n   :four-dy-square        (* 4.0 (pow dy 2))\n   :dx-dy-squares         (* (pow dx 2) (pow dy 2))\n   :dx-dy                 (* dx dy)\n   :over-dx               (/ 1.0 dx)\n   :over-dy               (/ 1.0 dy)\n   :dt-over-dx            (/ dt dx)\n   :dt-over-dy            (/ dt dy)\n   :dt-over-dx-square     (/ dt (pow dx 2))\n   :dt-over-dy-square     (/ dt (pow dy 2))\n   :two-dx-dy-squares-sum (* 2.0 (+ (pow dx 2) (pow dy 2)))\n   :dx-dy-squares-over-two-dx-dy-squares-sum\n   (/ (* (pow dx 2) (pow dy 2)) (* 2.0 (+ (pow dx 2) (pow dy 2))))\n   :dt-over-two-rho-dx    (/ dt (* 2.0 rho dx))\n   :dt-over-two-rho-dy    (/ dt (* 2.0 rho dy))})\n\n\n(def array-u (two-d/create-init-zeros-u (assoc spatial-init-params :d-type Double/TYPE) spatial-array))\n\n\n(def array-v (two-d/clone-2d-array array-u))\n\n\n(def array-p (two-d/clone-2d-array array-u))\n\n\n(def array-b (two-d/clone-2d-array array-u))\n\nNow we define initial parameters:\n\n(def init-params\n  (-&gt; (merge spatial-init-params pre-calculation-params)\n      (assoc :rho rho\n             :nu nu\n             :dt dt\n             :nit nit\n             :nt nt\n             :spatial-array spatial-array\n             :array-u array-u\n             :array-v array-v\n             :array-p array-p\n             :array-b array-b)))\n\nThe pressure Poisson equation that’s written above can be hard to write out without typos. The function build-up-b below represents the contents of the square brackets, so that the entirety of the PPE is slightly more manageable.\n\n(defn build-up-b [{:keys [array-b array-u array-v rho dt dx dy nx ny\n                          x-second-end-idx y-second-end-idx\n                          two-dx\n                          two-dy\n                          two-dx-dy\n                          four-dx-square\n                          four-dy-square] :as _params}]\n  (dotimes [y-idx y-second-end-idx]\n    (dotimes [x-idx x-second-end-idx]\n      (let [;; index definitions\n            y-prev-idx y-idx\n            x-prev-idx x-idx\n            y-idx      (inc y-idx)\n            x-idx      (inc x-idx)\n            y-next-idx (inc y-idx)\n            x-next-idx (inc x-idx)\n\n            ;; extracting array values\n            u-i-j-1    (aget array-u y-prev-idx x-idx)\n            u-i-j+1    (aget array-u y-next-idx x-idx)\n            u-j-i-1    (aget array-u y-idx x-prev-idx)\n            u-j-i+1    (aget array-u y-idx x-next-idx)\n\n            v-i-j-1    (aget array-v y-prev-idx x-idx)\n            v-i-j+1    (aget array-v y-next-idx x-idx)\n            v-j-i-1    (aget array-v y-idx x-prev-idx)\n            v-j-i+1    (aget array-v y-idx x-next-idx)\n\n            ;; pre-calculations\n            u-i-diff   (- u-j-i+1 u-j-i-1)\n            u-j-diff   (- u-i-j+1 u-i-j-1)\n            v-i-diff   (- v-j-i+1 v-j-i-1)\n            v-j-diff   (- v-i-j+1 v-i-j-1)]\n        (aset array-b y-idx x-idx\n          (double\n            (* rho\n               (- (/ (+ (/ u-i-diff two-dx) (/ v-j-diff two-dy)) dt)\n                  (/ (* u-i-diff u-i-diff) four-dx-square)\n                  (/ (* u-j-diff v-i-diff) two-dx-dy)\n                  (/ (* v-j-diff v-j-diff) four-dy-square)))))))))\n\nThe function pressure-poisson is also defined to help segregate the different rounds of calculations. Note the presence of the pseudo-time variable nit. This sub-iteration in the Poisson calculation helps ensure a divergence-free field.\n\n(defn pressure-poisson [{:keys [array-p array-b nx ny dx dy nit\n                                x-end-idx y-end-idx\n                                x-second-end-idx y-second-end-idx\n                                dx-square\n                                dy-square\n                                two-dx-dy-squares-sum\n                                dx-dy-squares-over-two-dx-dy-squares-sum]\n                         :as   _params}]\n  (loop [t-idx 0]\n    (when (not= t-idx nit)\n      (let [pn (two-d/clone-2d-array array-p)]\n        (dotimes [y-idx y-second-end-idx]\n          (dotimes [x-idx x-second-end-idx]\n            (let [y-prev-idx y-idx\n                  x-prev-idx x-idx\n                  y-idx      (inc y-idx)\n                  x-idx      (inc x-idx)\n                  y-next-idx (inc y-idx)\n                  x-next-idx (inc x-idx)\n\n                  p-i-j-1    (aget pn y-prev-idx x-idx)\n                  p-i-j+1    (aget pn y-next-idx x-idx)\n                  p-j-i-1    (aget pn y-idx x-prev-idx)\n                  p-j-i+1    (aget pn y-idx x-next-idx)\n                  p-i-sum    (+ p-j-i+1 p-j-i-1)\n                  p-j-sum    (+ p-i-j+1 p-i-j-1)]\n              (aset array-p y-idx x-idx\n                (double (- (/ (+ (* p-i-sum dy-square)\n                                 (* p-j-sum dx-square))\n                              two-dx-dy-squares-sum)\n                           (* dx-dy-squares-over-two-dx-dy-squares-sum\n                              (aget array-b y-idx x-idx))))))))\n        ;; boundary conditions\n        ;; dp/dx = 0 at x = 2 & dp/dx = 0 at x = 0\n        (dotimes [y-idx ny]\n          (aset array-p y-idx x-end-idx (aget array-p y-idx x-second-end-idx))\n          (aset array-p y-idx 0 (aget array-p y-idx 1)))\n        ;; dp/dy = 0 at y = 0 & p = 0 at y = 2\n        (dotimes [x-idx nx]\n          (aset array-p 0 x-idx (aget array-p 1 x-idx))\n          (aset array-p y-end-idx x-idx 0.0))\n        (recur (inc t-idx))))))\n\nFinally, the rest of the cavity flow equations are wrapped inside the function cavity-flow, allowing us to easily plot the results of the cavity flow solver for different lengths of time.\n\n(defn cavity-flow [{:keys [nt array-u array-v array-p dt nx ny dx dy rho nu\n                           x-end-idx y-end-idx\n                           x-second-end-idx y-second-end-idx\n                           dt-over-dx\n                           dt-over-dy\n                           dt-over-dx-square\n                           dt-over-dy-square\n                           two-dx-dy-squares-sum\n                           dt-over-two-rho-dx\n                           dt-over-two-rho-dy] :as params}]\n  (loop [n 0]\n    (if (= n nt)\n      params\n      (let [un (two-d/clone-2d-array array-u)\n            vn (two-d/clone-2d-array array-v)]\n        (build-up-b params)\n        (pressure-poisson params)\n        (dotimes [y-idx y-second-end-idx]\n          (dotimes [x-idx x-second-end-idx]\n            (let [y-prev-idx    y-idx\n                  x-prev-idx    x-idx\n                  y-idx         (inc y-idx)\n                  x-idx         (inc x-idx)\n                  y-next-idx    (inc y-idx)\n                  x-next-idx    (inc x-idx)\n\n                  u-i-j         (aget un y-idx x-idx)\n                  u-i-j-1       (aget un y-prev-idx x-idx)\n                  u-i-j+1       (aget un y-next-idx x-idx)\n                  u-j-i-1       (aget un y-idx x-prev-idx)\n                  u-j-i+1       (aget un y-idx x-next-idx)\n                  neg-two-u-i-j (* -2.0 u-i-j)\n\n                  v-i-j         (aget vn y-idx x-idx)\n                  v-i-j-1       (aget vn y-prev-idx x-idx)\n                  v-i-j+1       (aget vn y-next-idx x-idx)\n                  v-j-i-1       (aget vn y-idx x-prev-idx)\n                  v-j-i+1       (aget vn y-idx x-next-idx)\n                  neg-two-v-i-j (* -2.0 v-i-j)\n\n                  p-j-i+1       (aget array-p y-idx x-next-idx)\n                  p-j-i-1       (aget array-p y-idx x-prev-idx)\n                  p-i-j+1       (aget array-p y-next-idx x-idx)\n                  p-i-j-1       (aget array-p y-prev-idx x-idx)]\n              (aset array-u y-idx x-idx\n                (double (- u-i-j\n                           (* u-i-j dt-over-dx (- u-i-j u-j-i-1))\n                           (* v-i-j dt-over-dy (- u-i-j u-i-j-1))\n                           (* dt-over-two-rho-dx (- p-j-i+1 p-j-i-1))\n                           (* -1.0 nu\n                              (+ (* dt-over-dx-square\n                                    (+ u-j-i+1 neg-two-u-i-j u-j-i-1))\n                                 (* dt-over-dy-square\n                                    (+ u-i-j+1 neg-two-u-i-j u-i-j-1)))))))\n\n              (aset array-v y-idx x-idx\n                (- v-i-j\n                   (* v-i-j dt-over-dx (- v-i-j v-j-i-1))\n                   (* u-i-j dt-over-dy (- v-i-j v-i-j-1))\n                   (* dt-over-two-rho-dy (- p-i-j+1 p-i-j-1))\n                   (* -1.0 nu\n                      (+ (* dt-over-dx-square\n                            (+ v-j-i+1 neg-two-v-i-j v-j-i-1))\n                         (* dt-over-dy-square\n                            (+ v-i-j+1 neg-two-v-i-j v-i-j-1)))))))))\n\n        ;; boundary conditions\n        (dotimes [y-idx ny]\n          (aset array-u y-idx 0 0.0)\n          (aset array-u y-idx x-end-idx 0.0)\n          (aset array-v y-idx 0 0.0)\n          (aset array-v y-idx x-end-idx 0.0))\n        (dotimes [x-idx nx]\n          (aset array-u 0 x-idx 0.0)\n          (aset array-u y-end-idx x-idx 1.0) ;; set velocity on cavity lid equal to 1\n          (aset array-v 0 x-idx 0.0)\n          (aset array-v y-end-idx x-idx 0.0))\n        (recur (inc n))))))\n\nnt = 100\n\n\nsource: notebooks/steps/step_11.clj",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Step 11: Cavity Flow with Navier-Stokes</span>"
    ]
  },
  {
    "objectID": "steps.step_12.html",
    "href": "steps.step_12.html",
    "title": "14  Step 12: Channel Flow with Navier-Stokes",
    "section": "",
    "text": "Did you make it this far? This is the last step! How long did it take you to write your own Navier-stoke solver in Clojure following the interactive module? Let us know!\nThe only difference between this final step and Step 11 is that we are going to add a source term to the \\(u\\)-momentum equation, to mimic the effect of a pressure-driven channel flow. Here are our modified Navier-Stokes equations:\n\\[\\frac{\\partial u}{\\partial t}+u\\frac{\\partial u}{\\partial x}+v\\frac{\\partial u}{\\partial y}=-\\frac{1}{\\rho}\\frac{\\partial p}{\\partial x}+\\nu\\left(\\frac{\\partial^2 u}{\\partial x^2}+\\frac{\\partial^2 u}{\\partial y^2}\\right)+F\\]\n\\[\\frac{\\partial v}{\\partial t}+u\\frac{\\partial v}{\\partial x}+v\\frac{\\partial v}{\\partial y}=-\\frac{1}{\\rho}\\frac{\\partial p}{\\partial y}+\\nu\\left(\\frac{\\partial^2 v}{\\partial x^2}+\\frac{\\partial^2 v}{\\partial y^2}\\right)\\]\n\\[\\frac{\\partial^2 p}{\\partial x^2}+\\frac{\\partial^2 p}{\\partial y^2}=-\\rho\\left(\\frac{\\partial u}{\\partial x}\\frac{\\partial u}{\\partial x}+2\\frac{\\partial u}{\\partial y}\\frac{\\partial v}{\\partial x}+\\frac{\\partial v}{\\partial y}\\frac{\\partial v}{\\partial y}\\right)\\]\n\n14.0.1 Discretized equations\nWith patience and care, we write the discretized form of the equations. It is highly recommended that you write these in your own hand, mentally following each term as you write it.\nThe \\(u\\)-momentum equation:\n\\[\\begin{split}\n& \\frac{u_{i,j}^{n+1}-u_{i,j}^{n}}{\\Delta t}+u_{i,j}^{n}\\frac{u_{i,j}^{n}-u_{i-1,j}^{n}}{\\Delta x}+v_{i,j}^{n}\\frac{u_{i,j}^{n}-u_{i,j-1}^{n}}{\\Delta y} = \\\\\n& \\qquad -\\frac{1}{\\rho}\\frac{p_{i+1,j}^{n}-p_{i-1,j}^{n}}{2\\Delta x} \\\\\n& \\qquad +\\nu\\left(\\frac{u_{i+1,j}^{n}-2u_{i,j}^{n}+u_{i-1,j}^{n}}{\\Delta x^2}+\\frac{u_{i,j+1}^{n}-2u_{i,j}^{n}+u_{i,j-1}^{n}}{\\Delta y^2}\\right)+F_{i,j}\n\\end{split}\\]\nThe \\(v\\)-momentum equation:\n\\[\\begin{split}\n& \\frac{v_{i,j}^{n+1}-v_{i,j}^{n}}{\\Delta t}+u_{i,j}^{n}\\frac{v_{i,j}^{n}-v_{i-1,j}^{n}}{\\Delta x}+v_{i,j}^{n}\\frac{v_{i,j}^{n}-v_{i,j-1}^{n}}{\\Delta y} = \\\\\n& \\qquad -\\frac{1}{\\rho}\\frac{p_{i,j+1}^{n}-p_{i,j-1}^{n}}{2\\Delta y} \\\\\n& \\qquad +\\nu\\left(\\frac{v_{i+1,j}^{n}-2v_{i,j}^{n}+v_{i-1,j}^{n}}{\\Delta x^2}+\\frac{v_{i,j+1}^{n}-2v_{i,j}^{n}+v_{i,j-1}^{n}}{\\Delta y^2}\\right)\n\\end{split}\\]\nAnd the pressure equation:\n\\[\\begin{split}\n& \\frac{p_{i+1,j}^{n}-2p_{i,j}^{n}+p_{i-1,j}^{n}}{\\Delta x^2} + \\frac{p_{i,j+1}^{n}-2p_{i,j}^{n}+p_{i,j-1}^{n}}{\\Delta y^2} = \\\\\n& \\qquad \\rho\\left[\\frac{1}{\\Delta t}\\left(\\frac{u_{i+1,j}-u_{i-1,j}}{2\\Delta x}+\\frac{v_{i,j+1}-v_{i,j-1}}{2\\Delta y}\\right) - \\frac{u_{i+1,j}-u_{i-1,j}}{2\\Delta x}\\frac{u_{i+1,j}-u_{i-1,j}}{2\\Delta x} - 2\\frac{u_{i,j+1}-u_{i,j-1}}{2\\Delta y}\\frac{v_{i+1,j}-v_{i-1,j}}{2\\Delta x} - \\frac{v_{i,j+1}-v_{i,j-1}}{2\\Delta y}\\frac{v_{i,j+1}-v_{i,j-1}}{2\\Delta y}\\right]\n\\end{split}\\]\nAs always, we need to re-arrange these equations to the form we need in the code to make the iterations proceed.\nFor the \\(u\\) and \\(v\\) momentum equations, we isolate the velocity at the time step n+1:\n\\[\\begin{split}\nu_{i,j}^{n+1} = u_{i,j}^{n} & - u_{i,j}^{n} \\frac{\\Delta t}{\\Delta x} \\left(u_{i,j}^{n}-u_{i-1,j}^{n}\\right) - v_{i,j}^{n} \\frac{\\Delta t}{\\Delta y} \\left(u_{i,j}^{n}-u_{i,j-1}^{n}\\right) \\\\\n& - \\frac{\\Delta t}{\\rho 2\\Delta x} \\left(p_{i+1,j}^{n}-p_{i-1,j}^{n}\\right) \\\\\n& + \\nu\\left[\\frac{\\Delta t}{\\Delta x^2} \\left(u_{i+1,j}^{n}-2u_{i,j}^{n}+u_{i-1,j}^{n}\\right) + \\frac{\\Delta t}{\\Delta y^2} \\left(u_{i,j+1}^{n}-2u_{i,j}^{n}+u_{i,j-1}^{n}\\right)\\right] \\\\\n& + \\Delta t F\n\\end{split}\\]\n\\[\\begin{split}\nv_{i,j}^{n+1} = v_{i,j}^{n} & - u_{i,j}^{n} \\frac{\\Delta t}{\\Delta x} \\left(v_{i,j}^{n}-v_{i-1,j}^{n}\\right) - v_{i,j}^{n} \\frac{\\Delta t}{\\Delta y} \\left(v_{i,j}^{n}-v_{i,j-1}^{n}\\right) \\\\\n& - \\frac{\\Delta t}{\\rho 2\\Delta y} \\left(p_{i,j+1}^{n}-p_{i,j-1}^{n}\\right) \\\\\n& + \\nu\\left[\\frac{\\Delta t}{\\Delta x^2} \\left(v_{i+1,j}^{n}-2v_{i,j}^{n}+v_{i-1,j}^{n}\\right) + \\frac{\\Delta t}{\\Delta y^2} \\left(v_{i,j+1}^{n}-2v_{i,j}^{n}+v_{i,j-1}^{n}\\right)\\right]\n\\end{split}\\]\nAnd for the pressure equation, we isolate the term \\(p_{i,j}^n\\) to iterate in pseudo-time:\n\\[\\begin{split}\np_{i,j}^{n} = & \\frac{\\left(p_{i+1,j}^{n}+p_{i-1,j}^{n}\\right) \\Delta y^2 + \\left(p_{i,j+1}^{n}+p_{i,j-1}^{n}\\right) \\Delta x^2}{2(\\Delta x^2+\\Delta y^2)} \\\\\n& -\\frac{\\rho\\Delta x^2\\Delta y^2}{2\\left(\\Delta x^2+\\Delta y^2\\right)} \\\\\n& \\times \\left[\\frac{1}{\\Delta t} \\left(\\frac{u_{i+1,j}-u_{i-1,j}}{2\\Delta x} + \\frac{v_{i,j+1}-v_{i,j-1}}{2\\Delta y}\\right) - \\frac{u_{i+1,j}-u_{i-1,j}}{2\\Delta x}\\frac{u_{i+1,j}-u_{i-1,j}}{2\\Delta x} - 2\\frac{u_{i,j+1}-u_{i,j-1}}{2\\Delta y}\\frac{v_{i+1,j}-v_{i-1,j}}{2\\Delta x} - \\frac{v_{i,j+1}-v_{i,j-1}}{2\\Delta y}\\frac{v_{i,j+1}-v_{i,j-1}}{2\\Delta y}\\right]\n\\end{split}\\]\nThe initial condition is \\(u, v, p = 0\\) everywhere, and at the boundary conditions are: \\(u, v, p\\) are periodic on \\(x = 0, 2\\)  \\(u, v = 0\\) at \\(y = 0, 2\\)  \\(\\frac{\\partial p}{\\partial y} = 0\\) at \\(y = 0, 2\\)  \\(F = 1\\) everywhere\nIn step 11, we isolated a portion of our transposed equation to make it easier to parse and we’re going to do the same thing here. One thing to note is that we have periodic boundary conditions throughout this grid, so we need to explicitly calculate the values at the leading and trailing edge of our u vector.\n\n(defn build-up-b [{:keys [array-b array-u array-v rho dt dx dy nx ny\n                          x-end-idx y-end-idx\n                          x-second-end-idx y-second-end-idx\n                          two-dx\n                          two-dy\n                          two-dx-dy\n                          four-dx-square\n                          four-dy-square] :as _params}]\n  (dotimes [y-idx y-second-end-idx]\n    (let [y-prev-idx                 y-idx\n          y-idx                      (inc y-idx)\n          y-next-idx                 (inc y-idx)\n\n          u-prev-x                   (aget array-u y-prev-idx)\n          u-x                        (aget array-u y-idx)\n          u-next-x                   (aget array-u y-next-idx)\n          v-prev-x                   (aget array-v y-prev-idx)\n          v-x                        (aget array-v y-idx)\n          v-next-x                   (aget array-v y-next-idx)\n\n          u-x-start                  (aget u-x 0)\n          u-x-2nd                    (aget u-x 1)\n          u-x-2nd-end                (aget u-x x-second-end-idx)\n          u-x-end                    (aget u-x x-end-idx)\n          u-next-x-start             (aget u-next-x 0)\n          u-prev-x-start             (aget u-prev-x 0)\n          u-next-x-end               (aget u-next-x x-end-idx)\n          u-prev-x-end               (aget u-prev-x x-end-idx)\n\n          v-x-start                  (aget v-x 0)\n          v-x-2nd                    (aget v-x 1)\n          v-x-2nd-end                (aget v-x x-second-end-idx)\n          v-x-end                    (aget v-x x-end-idx)\n          v-next-x-start             (aget v-next-x 0)\n          v-prev-x-start             (aget v-prev-x 0)\n          v-next-x-end               (aget v-next-x x-end-idx)\n          v-prev-x-end               (aget v-prev-x x-end-idx)\n\n          u-x-start-end-diff         (- u-x-start u-x-2nd-end)\n          u-x-start-end-diff-sqr     (* u-x-start-end-diff u-x-start-end-diff)\n\n          v-next-prev-end-diff       (- v-next-x-end v-prev-x-end)\n          v-next-prev-end-diff-sqr   (* v-next-prev-end-diff v-next-prev-end-diff)\n\n          u-x-2nd-end-diff           (- u-x-2nd u-x-end)\n          u-x-2nd-end-diff-sqr       (* u-x-2nd-end-diff u-x-2nd-end-diff)\n\n          v-next-prev-start-diff     (- v-next-x-start v-prev-x-start)\n          v-next-prev-start-diff-sqr (* v-next-prev-start-diff v-next-prev-start-diff)]\n      (dotimes [x-idx x-second-end-idx]\n        (let [;; index definitions\n              x-prev-idx x-idx\n              x-idx      (inc x-idx)\n              x-next-idx (inc x-idx)\n\n              ;; extracting array values\n              u-i-j-1    (aget u-prev-x x-idx)\n              u-i-j+1    (aget u-next-x x-idx)\n              u-j-i-1    (aget u-x x-prev-idx)\n              u-j-i+1    (aget u-x x-next-idx)\n\n              v-i-j-1    (aget v-prev-x x-idx)\n              v-i-j+1    (aget v-next-x x-idx)\n              v-j-i-1    (aget v-x x-prev-idx)\n              v-j-i+1    (aget v-x x-next-idx)\n\n              ;; pre-calculations\n              u-i-diff   (- u-j-i+1 u-j-i-1)\n              u-j-diff   (- u-i-j+1 u-i-j-1)\n              v-i-diff   (- v-j-i+1 v-j-i-1)\n              v-j-diff   (- v-i-j+1 v-i-j-1)]\n          (aset array-b y-idx x-idx\n            (double (* rho\n                       (- (/ (+ (/ u-i-diff two-dx) (/ v-j-diff two-dy)) dt)\n                          (/ (* u-i-diff u-i-diff) four-dx-square)\n                          (/ (* u-j-diff v-i-diff) two-dx-dy)\n                          (/ (* v-j-diff v-j-diff) four-dy-square)))))))\n\n      ;; Periodic BC Pressure @ x = 2\n      (aset array-b y-idx x-end-idx\n        (double (* rho\n                   (- (/ (+ (/ u-x-start-end-diff two-dx)\n                            (/ v-next-prev-end-diff two-dy))\n                         dt)\n                      (/ u-x-start-end-diff-sqr four-dx-square)\n                      (/ (* (- u-next-x-end u-prev-x-end) (- v-x-start v-x-2nd-end)) two-dx-dy)\n                      (/ v-next-prev-end-diff-sqr four-dy-square)))))\n\n      ;; Periodic BC Pressure @ x = 0\n      (aset array-b y-idx 0\n        (double (* rho\n                   (- (/ (+ (/ u-x-2nd-end-diff two-dx)\n                            (/ v-next-prev-start-diff two-dy))\n                         dt)\n                      (/ u-x-2nd-end-diff-sqr four-dx-square)\n                      (/ (* (- u-next-x-start u-prev-x-start) (- v-x-2nd v-x-end)) two-dx-dy)\n                      (/ v-next-prev-start-diff-sqr four-dy-square))))))))\n\nWe’ll also define a Pressure Poisson iterative function, again like we did in Step 11. Once more, note that we have to include the periodic boundary conditions at the leading and trailing edge. We also have to specify the boundary conditions at the top and bottom of our grid.\n\n(defn pressure-poisson-periodic [{:keys [array-p array-b nx ny dx dy nit\n                                         x-end-idx y-end-idx\n                                         x-second-end-idx y-second-end-idx\n                                         dx-square\n                                         dy-square\n                                         two-dx-dy-squares-sum\n                                         dx-dy-squares-over-two-dx-dy-squares-sum]\n                                  :as   _params}]\n  (dotimes [_ nit]\n    (let [pn (two-d/clone-2d-array array-p)]\n      (dotimes [y-idx y-second-end-idx]\n        (let [y-prev-idx y-idx\n              y-idx      (inc y-idx)\n              y-next-idx (inc y-idx)\n\n              pn-x       (aget pn y-idx)\n              pn-prev-x  (aget pn y-prev-idx)\n              pn-next-x  (aget pn y-next-idx)\n              array-b-x  (aget array-b y-idx)]\n          (dotimes [x-idx x-second-end-idx]\n            (let [x-prev-idx   x-idx\n                  x-idx        (inc x-idx)\n                  x-next-idx   (inc x-idx)\n\n                  p-i-j-1      (aget pn-prev-x x-idx)\n                  p-i-j+1      (aget pn-next-x x-idx)\n                  p-j-i-1      (aget pn-x x-prev-idx)\n                  p-j-i+1      (aget pn-x x-next-idx)\n                  p-i-diff-sum (+ p-j-i+1 p-j-i-1)\n                  p-j-diff-sum (+ p-i-j+1 p-i-j-1)]\n              (aset array-p y-idx x-idx\n                (double (- (/ (+ (* p-i-diff-sum dy-square)\n                                 (* p-j-diff-sum dx-square))\n                              two-dx-dy-squares-sum)\n                           (* dx-dy-squares-over-two-dx-dy-squares-sum\n                              (aget array-b-x x-idx)))))))\n\n          ;; Periodic BC Pressure @ x = 2\n          (aset array-p y-idx x-end-idx\n            (double (- (/ (+ (* (+ (aget pn-x 0) (aget pn-x x-second-end-idx)) dy-square)\n                             (* (+ (aget pn-next-x x-end-idx) (aget pn-prev-x x-end-idx)) dx-square))\n                          two-dx-dy-squares-sum)\n                       (* dx-dy-squares-over-two-dx-dy-squares-sum\n                          (aget array-b-x x-end-idx)))))\n\n          ;; Periodic BC Pressure @ x = 0\n          (aset array-p y-idx 0\n            (double (- (/ (+ (* (+ (aget pn-x 1) (aget pn-x x-end-idx)) dy-square)\n                             (* (+ (aget pn-next-x 0) (aget pn-prev-x 0)) dx-square))\n                          two-dx-dy-squares-sum)\n                       (* dx-dy-squares-over-two-dx-dy-squares-sum\n                          (aget array-b-x 0)))))))\n\n      ;; Wall boundary conditions, pressure\n      (aset array-p y-end-idx (aget array-p y-second-end-idx))\n      (aset array-p 0 (aget array-p 1)))))\n\nNow we have our familiar list of variables and initial conditions to declare before we start.\n\n\n14.0.2 Variable Declarations\nSpatial setup:\n\n(def nx 41)\n\n\n(def ny 41)\n\n\n(def nt 10)\n\n\n(def nit 50)\n\n\n(def c 1)\n\n\n(def x-start 0)\n\n\n(def x-end 2)\n\n\n(def y-start 0)\n\n\n(def y-end 2)\n\n\n(def dx (double (/ (- x-end x-start) (dec nx))))\n\n\n(def dy (double (/ (- y-end y-start) (dec ny))))\n\n\n(def spatial-init-params\n  {:nx nx :x-start x-start :x-end x-end :dx dx :x-end-idx (dec nx) :x-second-end-idx (- nx 2)\n   :ny ny :y-start y-start :y-end y-end :dy dy :y-end-idx (dec ny) :y-second-end-idx (- ny 2)})\n\n\n(def spatial-array (two-d/create-array-2d spatial-init-params))\n\nThe rest setup:\n\n(def rho 1.0)\n\n\n(def nu 1e-1)\n\n\n(def F 1.0)\n\n\n(def dt 1e-2)\n\nDoing some pre-calculation to optimize the performance\n\n(def pre-calculation-params\n  {:two-dx                (* 2.0 dx)\n   :two-dy                (* 2.0 dy)\n   :two-dx-dy             (* 2.0 dx dy)\n   :dx-square             (pow dx 2)\n   :dy-square             (pow dy 2)\n   :four-dx-square        (* 4.0 (pow dx 2))\n   :four-dy-square        (* 4.0 (pow dy 2))\n   :dx-dy-squares         (* (pow dx 2) (pow dy 2))\n   :dx-dy                 (* dx dy)\n   :over-dx               (/ 1.0 dx)\n   :over-dy               (/ 1.0 dy)\n   :dt-over-dx            (/ dt dx)\n   :dt-over-dy            (/ dt dy)\n   :dt-over-dx-square     (/ dt (pow dx 2))\n   :dt-over-dy-square     (/ dt (pow dy 2))\n   :two-dx-dy-squares-sum (* 2.0 (+ (pow dx 2) (pow dy 2)))\n   :dx-dy-squares-over-two-dx-dy-squares-sum\n   (/ (* (pow dx 2) (pow dy 2)) (* 2.0 (+ (pow dx 2) (pow dy 2))))\n   :dt-over-two-rho-dx    (/ dt (* 2.0 rho dx))\n   :dt-over-two-rho-dy    (/ dt (* 2.0 rho dy))\n   :dt-F                  (* dt F)})\n\n\n(def array-u (two-d/create-init-zeros-u (assoc spatial-init-params :d-type Double/TYPE) spatial-array))\n\n\n(def array-v (two-d/clone-2d-array array-u))\n\n\n(def array-p (two-d/clone-2d-array array-u))\n\n\n(def array-b (two-d/clone-2d-array array-u))\n\nNow we define initial parameters:\n\n(def init-params\n  (-&gt; (merge spatial-init-params pre-calculation-params)\n      (assoc :rho rho\n             :nu nu\n             :dt dt\n             :nit nit\n             :nt nt\n             :F F\n             :spatial-array spatial-array\n             :array-u array-u\n             :array-v array-v\n             :array-p array-p\n             :array-b array-b)))\n\nFor the meat of our computation, we’re going to reach back to a trick we used in Step 9 for Laplace’s Equation. We’re interested in what our grid will look like once we’ve reached a near-steady state. We can either specify a number of timesteps nt and increment it until we’re satisfied with the results, or we can tell our code to run until the difference between two consecutive iterations is very small.\nWe also have to manage 8 separate boundary conditions for each iteration. The code below writes each of them out explicitly. If you’re interested in a challenge, you can try to write a function which can handle some or all these boundary conditions. At the moment, I am just trying to make the simulation running, so - todo: refactor it to be better\n\n(def default-u-diff 1.0)\n\n\n(def !step-count (atom 0))\n\n\n(def !u-diff (atom default-u-diff))\n\n\n(defn cavity-flow-periodic [{:keys [nt array-u array-v array-p dt nx ny dx dy rho nu\n                                    x-end-idx y-end-idx\n                                    x-second-end-idx y-second-end-idx\n                                    dt-over-dx\n                                    dt-over-dy\n                                    dt-over-dx-square\n                                    dt-over-dy-square\n                                    two-dx-dy-squares-sum\n                                    dt-over-two-rho-dx\n                                    dt-over-two-rho-dy\n                                    dt-F]\n                             :as   params}]\n  (let [neg-dt-F (- dt-F)]\n    (while (&gt; @!u-diff 1e-3)\n      (let [un (two-d/clone-2d-array array-u)\n            vn (two-d/clone-2d-array array-v)]\n        (build-up-b params)\n        (pressure-poisson-periodic params)\n        (dotimes [y-idx y-second-end-idx]\n          (let [y-prev-idx y-idx\n                y-idx      (inc y-idx)\n                y-next-idx (inc y-idx)\n\n                un-prev-x  (aget un y-prev-idx)\n                un-x       (aget un y-idx)\n                un-next-x  (aget un y-next-idx)\n\n                vn-prev-x  (aget vn y-prev-idx)\n                vn-x       (aget vn y-idx)\n                vn-next-x  (aget vn y-next-idx)\n\n                p-prev-x   (aget array-p y-prev-idx)\n                p-x        (aget array-p y-idx)\n                p-next-x   (aget array-p y-next-idx)]\n            (dotimes [x-idx x-second-end-idx]\n              (let [x-prev-idx    x-idx\n                    x-idx         (inc x-idx)\n                    x-next-idx    (inc x-idx)\n\n                    u-i-j         (aget un-x x-idx)\n                    u-i-j-1       (aget un-prev-x x-idx)\n                    u-i-j+1       (aget un-next-x x-idx)\n                    u-j-i-1       (aget un-x x-prev-idx)\n                    u-j-i+1       (aget un-x x-next-idx)\n                    neg-two-u-i-j (* -2.0 u-i-j)\n\n                    v-i-j         (aget vn-x x-idx)\n                    v-i-j-1       (aget vn-prev-x x-idx)\n                    v-i-j+1       (aget vn-next-x x-idx)\n                    v-j-i-1       (aget vn-x x-prev-idx)\n                    v-j-i+1       (aget vn-x x-next-idx)\n                    neg-two-v-i-j (* -2.0 v-i-j)\n\n                    p-j-i+1       (aget p-x x-next-idx)\n                    p-j-i-1       (aget p-x x-prev-idx)\n                    p-i-j+1       (aget p-next-x x-idx)\n                    p-i-j-1       (aget p-prev-x x-idx)]\n                (aset array-u y-idx x-idx\n                  (double (- u-i-j\n                             (* u-i-j dt-over-dx (- u-i-j u-j-i-1))\n                             (* v-i-j dt-over-dy (- u-i-j u-i-j-1))\n                             (* dt-over-two-rho-dx (- p-j-i+1 p-j-i-1))\n                             (* (- nu)\n                                (+ (* dt-over-dx-square\n                                      (+ u-j-i+1 neg-two-u-i-j u-j-i-1))\n                                   (* dt-over-dy-square\n                                      (+ u-i-j+1 neg-two-u-i-j u-i-j-1))))\n                             neg-dt-F)))\n\n                (aset array-v y-idx x-idx\n                  (double (- v-i-j\n                             (* u-i-j dt-over-dx (- v-i-j v-j-i-1))\n                             (* v-i-j dt-over-dy (- v-i-j v-i-j-1))\n                             (* dt-over-two-rho-dy (- p-i-j+1 p-i-j-1))\n                             (* (- nu)\n                                (+ (* dt-over-dx-square\n                                      (+ v-j-i+1 neg-two-v-i-j v-j-i-1))\n                                   (* dt-over-dy-square\n                                      (+ v-i-j+1 neg-two-v-i-j v-i-j-1)))))))))\n\n            ;; Boundary conditions\n            (let [un-x-end        (aget un-x x-end-idx)\n                  un-x-2nd-end    (aget un-x x-second-end-idx)\n                  un-x-start      (aget un-x 0)\n                  un-x-2nd        (aget un-x 1)\n                  un-prev-x-start (aget un-prev-x 0)\n                  un-prev-x-end   (aget un-prev-x x-end-idx)\n                  un-next-x-end   (aget un-next-x x-end-idx)\n                  un-next-x-start (aget un-next-x 0)\n\n                  vn-x-end        (aget vn-x x-end-idx)\n                  vn-x-2nd-end    (aget vn-x x-second-end-idx)\n                  vn-x-start      (aget vn-x 0)\n                  vn-x-2nd        (aget vn-x 1)\n                  vn-prev-x-start (aget vn-prev-x 0)\n                  vn-prev-x-end   (aget vn-prev-x x-end-idx)\n                  vn-next-x-end   (aget vn-next-x x-end-idx)\n                  vn-next-x-start (aget vn-next-x 0)\n\n                  p-x-start       (aget p-x 0)\n                  p-x-2nd         (aget p-x 1)\n                  p-x-end         (aget p-x x-end-idx)\n                  p-x-2nd-end     (aget p-x x-second-end-idx)\n                  p-next-x-start  (aget p-next-x 0)\n                  p-next-x-end    (aget p-next-x x-end-idx)\n                  p-prev-x-start  (aget p-prev-x 0)\n                  p-prev-x-end    (aget p-prev-x x-end-idx)]\n\n              ;; Periodic BC u @ x = 2\n              (aset array-u y-idx x-end-idx\n                (double (- un-x-end\n                           (* un-x-end dt-over-dx (- un-x-end un-x-2nd-end))\n                           (* vn-x-end dt-over-dy (- un-x-end un-prev-x-end))\n                           (* dt-over-two-rho-dx (- p-x-start p-x-2nd-end))\n                           (* (- nu)\n                              (+ (* dt-over-dx-square\n                                    (+ un-x-start (* -2.0 un-x-end) un-x-2nd-end))\n                                 (* dt-over-dy-square\n                                    (+ un-next-x-end (* -2.0 un-x-end) un-prev-x-end))))\n                           neg-dt-F)))\n\n              ;; Periodic BC u @ x = 0\n              (aset array-u y-idx 0\n                (double (- un-x-start\n                           (* un-x-start dt-over-dx (- un-x-start un-x-end))\n                           (* vn-x-start dt-over-dy (- un-x-start un-prev-x-start))\n                           (* dt-over-two-rho-dx (- p-x-2nd p-x-end))\n                           (* (- nu)\n                              (+ (* dt-over-dx-square\n                                    (+ un-x-2nd (* -2.0 un-x-start) un-x-end))\n                                 (* dt-over-dy-square\n                                    (+ un-next-x-start (* -2.0 un-x-start) un-prev-x-start))))\n                           neg-dt-F)))\n\n              ;; Periodic BC v @ x = 2\n              (aset array-v y-idx x-end-idx\n                (double (- vn-x-end\n                           (* un-x-end dt-over-dx (- vn-x-end vn-x-2nd-end))\n                           (* vn-x-end dt-over-dy (- vn-x-end vn-prev-x-end))\n                           (* dt-over-two-rho-dy (- p-next-x-end p-prev-x-end))\n                           (* (- nu)\n                              (+ (* dt-over-dx-square\n                                    (+ vn-x-start (* -2.0 vn-x-end) vn-x-2nd-end))\n                                 (* dt-over-dy-square\n                                    (+ vn-next-x-end (* -2.0 vn-x-end) vn-prev-x-end)))))))\n\n              ;; Periodic BC v @ x = 0\n              (aset array-v y-idx 0\n                (double (- vn-x-start\n                           (* un-x-start dt-over-dx (- vn-x-start vn-x-end))\n                           (* vn-x-start dt-over-dy (- vn-x-start vn-prev-x-start))\n                           (* dt-over-two-rho-dy (- p-next-x-start p-prev-x-start))\n                           (* (- nu)\n                              (+ (* dt-over-dx-square\n                                    (+ vn-x-2nd (* -2.0 vn-x-start) vn-x-end))\n                                 (* dt-over-dy-square\n                                    (+ vn-next-x-start (* -2.0 vn-x-start) vn-prev-x-start))))))))))\n\n        ;; Wall boundary conditions: u,v = 0 @ y = 0, 2\n        (dotimes [x-idx nx]\n          (aset array-u 0 x-idx 0.0)\n          (aset array-u y-end-idx x-idx 0.0)\n          (aset array-v 0 x-idx 0.0)\n          (aset array-v y-end-idx x-idx 0.0))\n\n        (let [sum-u  (reduce + 0.0 (mapcat identity array-u))\n              sum-un (reduce + 0.0 (mapcat identity un))\n              u-diff (if (zero? sum-u) 0.0 (/ (- sum-u sum-un) sum-u))]\n          (reset! !u-diff u-diff))\n        (swap! !step-count inc)))))\n\nRun the simulation\n\n(cavity-flow-periodic init-params)\n\n\nnil\n\nYou can see that we’ve also included !step-count to see how many iterations our loop went through before our stop condition was met.\n\n\"499\"\n\nIf you want to see how the number of iteration increases as our !u-diff condition gets smaller, try defining a function to perform the while loop written above that takes an input !u-diff` and outputs the number of iterations that the function runs.\nFor now, let’s look at our results. We’ve used the quiver functions to look at the cavity flow results and it works well for channel flow too.\n\n(two-d/plotly-quiver-plot init-params :step 3 :scale 0.1)\n\n\n:step 3 are useful when dealing with large amount of data that you want to visualize. The one used above tells plotly to only plot every 3rd data point. If we leave it out, you can see that the result can appear a little crowded since I set the default value 2 in the plotting function.\n\n\n14.0.3 Learn more\nWhat is the meaning of the \\(F\\) term?\nStep 12 is an exercise demonstrating the problem of flow in a channel or pipe. If you recall from fluid mechanics class, a specified pressure gradient is what drives Poisseulle flow.\nRecall the \\(x\\)-momentum equation:\n\\[\\frac{\\partial u}{\\partial t}+u \\cdot \\nabla u = -\\frac{\\partial p}{\\partial x}+\\nu \\nabla^2 u\\]\nWhat we actually do in Step 12 is split the pressure into steady and unsteady components \\(p=P+p'\\). The applied steady pressure gradient is the constant \\(-\\frac{\\partial P}{\\partial x}=F\\)(interpreted as a source term), and the unsteady component is \\(\\frac{\\partial p'}{\\partial x}\\). So the pressure that we solve for in Step 12 is actually \\(p'\\), which for a steady flow is in fact equal to zero everywhere.\nWhy did we do this?\nNote that we used periodic boundary conditions for this flow. For a flow with a constant pressure gradient, the value of pressure on the left edge of the domain must be different from the pressure at the right edge. So we cannot apply periodic boundary conditions on the pressure directly. It is easier to fix the gradient and solve the perturbations in pressure.\nShouldn’t we always expect a uniform/constant \\(p'\\) then?\nThat’s true only in the case of steady laminar flows. At high Reynolds numbers, flows in channels can become turbulent, and we will see unsteady fluctuations in the pressure, which will result in non-zero values for \\(p'\\).\nIn step 12, note that the pressure field itself is not constant, but it’s the pressure perturbation field is. The pressure field varies linearly along the channel with slope equal to the pressure gradient. Also, for incompressible flows, the absolute value of the pressure is inconsequential.\nAnd explore more CFD materials online\nThe interactive module 12 steps to Navier-Stokes is one of several components of the Computational Fluid Dynamics class taught by Prof. Lorena A. Barba in Boston University between 2009 and 2013.\nFor a sample of what the other components of this class are, you can explore the Resources section of the Spring 2013 version of the course’s Piazza site.\n\nsource: notebooks/steps/step_12.clj",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Step 12: Channel Flow with Navier-Stokes</span>"
    ]
  }
]